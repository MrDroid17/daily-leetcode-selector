[
    {
        "id": 241,
        "question": "## What are Branded Types (or Nominal Typing) in TypeScript?",
        "example": "```typescript\ntype Brand<K, T> = K & { __brand: T };\n\ntype UserId = Brand<string, 'UserId'>;\ntype ProductId = Brand<string, 'ProductId'>;\n\nfunction processUserId(id: UserId) { /* ... */ }\n\nconst userId = 'user-123' as UserId;\nconst productId = 'prod-456' as ProductId;\n\nprocessUserId(userId); // OK\n// processUserId(productId); // Error: Type 'ProductId' is not assignable to type 'UserId'.\n```",
        "solution": "TypeScript's type system is structural ('duck typing'). Branded Types are a pattern to simulate nominal typing, where two types with the same structure are not considered compatible. By adding a unique, private `__brand` property to a type, you can ensure that a `UserId` cannot be accidentally used where a `ProductId` is expected, even if both are fundamentally strings. This prevents a common class of logical errors.",
        "category": "TypeScript",
        "difficulty": "Hard"
    },
    {
        "id": 242,
        "question": "## What is the `never` type in TypeScript and when is it used?",
        "example": "```typescript\n// A function that always throws an error never returns a value.\nfunction throwError(message: string): never {\n  throw new Error(message);\n}\n\n// A function with an infinite loop also has a 'never' return type.\nfunction infiniteLoop(): never {\n  while (true) {}\n}\n```",
        "solution": "The `never` type represents a value that **never occurs**. It is used in two main scenarios:\n\n1.  As the return type for a function that **always throws an error**.\n2.  As the return type for a function that has an **infinite loop**.\n\nIt is also used in exhaustive checks in `switch` statements to ensure all cases are handled. If a new case is added to a union type, the compiler will throw an error if it's not handled, because the variable would fall into a `never` type.",
        "category": "TypeScript",
        "difficulty": "Medium"
    },
    {
        "id": 243,
        "question": "## What are Decorators in TypeScript?",
        "example": "```typescript\n// A simple method decorator for logging\nfunction LogMethod(target: any, propertyName: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n  descriptor.value = function(...args: any[]) {\n    console.log(`Calling method: ${propertyName}`);\n    return originalMethod.apply(this, args);\n  };\n}\n\nclass Calculator {\n  @LogMethod\n  add(a: number, b: number) {\n    return a + b;\n  }\n}\n```",
        "solution": "Decorators are a special kind of declaration that can be attached to a class, method, accessor, property, or parameter. They are functions that receive information about the decorated item and can be used to modify or observe it. Decorators are an experimental feature that must be enabled with `\"experimentalDecorators\": true` in `tsconfig.json`. They are heavily used in frameworks like Angular and NestJS for dependency injection, routing, and more.",
        "category": "TypeScript",
        "difficulty": "Hard"
    },
    {
        "id": 244,
        "question": "## What is the purpose of the `satisfies` operator in TypeScript?",
        "example": "```typescript\ntype RGB = [number, number, number];\n\n// Without 'satisfies', the type of 'palette' is inferred too broadly.\nconst palette = {\n  red: [255, 0, 0],\n  green: \"#00ff00\", // No error here, but we want to enforce the type\n  blue: [0, 0, 255]\n} satisfies Record<string, RGB | string>;\n\n// Now, TypeScript knows 'palette.red' is an array, not 'RGB | string'.\nconst redComponent = palette.red.join(','); // OK\n```",
        "solution": "The `satisfies` operator (introduced in TS 4.9) allows you to validate that an expression matches a certain type **without changing the inferred type** of that expression. This is useful when you want to ensure an object conforms to a broader type (like a `Record`) but still retain the specific, narrower types of its properties for later use. It helps catch errors early while preserving type inference.",
        "category": "TypeScript",
        "difficulty": "Medium"
    },
    {
        "id": 245,
        "question": "## How can you create a type-safe custom hook in React with TypeScript?",
        "example": "```tsx\nimport { useState, useEffect } from 'react';\n\n// A generic custom hook for fetching data\nfunction useFetch<T>(url: string): { data: T | null; loading: boolean; error: Error | null } {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    // ... fetch logic\n  }, [url]);\n\n  return { data, loading, error };\n}\n\n// Usage\nconst { data: user } = useFetch<User>('/api/users/1');\n```",
        "solution": "To create a type-safe custom hook, you should use **generics**. By defining a generic type parameter (e.g., `<T>`), your hook can work with any data type while maintaining type safety. The hook's return type should be explicitly defined to describe the shape of the object it returns (e.g., `{ data: T | null; loading: boolean; error: Error | null }`). When using the hook, you provide the specific type you expect to receive, which enables full type checking and autocompletion in your component.",
        "category": "TypeScript",
        "difficulty": "Medium"
    },
    {
        "id": 246,
        "question": "## Merge user and profile objects by user ID",
        "example": "```javascript\nconst users1 = [\n  { id: 1, email: 'dcontreras@email.tld' },\n  { id: 2, email: 'afeher@email.tld' },\n  { id: 3, email: 'odj@email.tld' },\n];\n\nconst profiles1 = [\n  { userId: 1, firstName: 'Danielle', lastName: 'Contreras' },\n  { userId: 2, firstName: 'Alfredas', lastName: 'Fehér' },\n  { userId: 3, firstName: 'Orpheus', lastName: 'De Jong' },\n];\n\n// Expected output:\nconst output = [\n    { id: 1, email: 'dcontreras@email.tld', profile: { userId: 1, firstName: 'Danielle', lastName: 'Contreras' } },\n    { id: 2, email: 'afeher@email.tld', profile: { userId: 2, firstName: 'Alfredas', lastName: 'Fehér' } },\n    { id: 3, email: 'odj@email.tld', profile: { userId: 3, firstName: 'Orpheus', lastName: 'De Jong' } },\n]\n```",
        "solution": "**Solution 1: Using map() with find()**\n```javascript\nconst output = users1.map(user => ({\n  ...user,\n  profile: profiles1.find(profile => profile.userId === user.id)\n}));\n```\n\n**Solution 2: Using HashMap for O(n) performance**\n```javascript\nfunction mergeUserProfiles(users, profiles) {\n    // Create a map for O(1) profile lookup\n    const profileMap = {};\n    profiles.forEach(profile => {\n        profileMap[profile.userId] = profile;\n    });\n    \n    // Map users with their profiles\n    return users.map(user => ({\n        ...user,\n        profile: profileMap[user.id]\n    }));\n}\n```\n\n**Performance Note:** Solution 1 has O(n²) complexity due to find() inside map(). Solution 2 is more efficient with O(n) complexity by creating a lookup map first.",
        "category": "JavaScript",
        "difficulty": "Medium"
    },
    {
        "id": 247,
        "question": "## What would be the output of `null == undefined` vs `null === undefined`?",
        "example": "```javascript\nconsole.log(null == undefined);\nconsole.log(null === undefined);\n\n// Additional comparisons:\nconsole.log(typeof null);\nconsole.log(typeof undefined);\nconsole.log(null == null);\nconsole.log(undefined === undefined);\n```",
        "solution": "**Output:**\n```\ntrue\nfalse\nobject\nundefined\ntrue\ntrue\n```\n\n**Detailed Explanation:**\n\n**1. Loose Equality (`==`) - Abstract Equality Comparison:**\n- `null == undefined` returns `true`\n- JavaScript's `==` operator performs type coercion before comparison\n- According to ECMAScript specification, `null` and `undefined` are considered equal when using `==`\n- This is a special case defined in the language specification (Section 7.2.14)\n- No type conversion actually occurs here - it's explicitly defined that `null == undefined` returns `true`\n\n**2. Strict Equality (`===`) - Strict Equality Comparison:**\n- `null === undefined` returns `false`\n- The `===` operator checks both **value AND type** without any coercion\n- `null` and `undefined` are different types:\n  - `typeof null` returns `\"object\"` (this is actually a known JavaScript bug/quirk)\n  - `typeof undefined` returns `\"undefined\"`\n- Since they have different types, `===` returns `false`\n\n**Best Practice:**\n```javascript\n// ✅ Check for both null and undefined\nif (value == null) { /* handles both */ }\n\n// ✅ Modern approach: Use nullish coalescing\nconst result = value ?? \"default value\";\n\n// ✅ Specific checks\nif (value === null) { /* only null */ }\nif (value === undefined) { /* only undefined */ }\n```",
        "category": "JavaScript",
        "difficulty": "Medium"
    }
]