[
    {
        "id": 61,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tconsole.log(typeof displayFunc);\n\tvar displayFunc = function(){\n\t\tconsole.log(\"Hi I am inside displayFunc\");\n\t}\n}());\n```\n\n1. undefined\n2. function\n3. 'Hi I am inside displayFunc'\n4. ReferenceError: displayFunc is not defined",
        "example": "```javascript\n// Function declaration vs function expression hoisting\nfunction test1() {\n    console.log(typeof myFunc); // 'function' (declaration hoisted)\n    function myFunc() { return 'declared'; }\n}\n\nfunction test2() {\n    console.log(typeof myFunc); // 'undefined' (only var hoisted)\n    var myFunc = function() { return 'expression'; };\n}\n\ntest1(); // 'function'\ntest2(); // 'undefined'\n```",
        "solution": "**Answer: 1) undefined**\n\n**Explanation:** This demonstrates the difference between function declarations and function expressions. Here, `displayFunc` is a function expression (assigned to a variable), not a function declaration. Only the variable declaration is hoisted, not the function assignment. The code effectively becomes:\n\n```javascript\n(function() {\n\tvar displayFunc; // hoisted variable declaration\n\tconsole.log(typeof displayFunc); // undefined\n\tdisplayFunc = function(){  // assignment happens here\n\t\tconsole.log(\"Hi I am inside displayFunc\");\n\t}\n}());\n```",
        "category": "Hoisting",
        "difficulty": "Medium"
    },
    {
        "id": 62,
        "question": "## What would be the output of following code?\n\n```javascript\nvar employeeId = 'abc123';\nfunction foo(){\n\temployeeId = '123bcd';\n\treturn;\n}\nfoo();\nconsole.log(employeeId);\n```\n\n1. undefined\n2. '123bcd'\n3. 'abc123'\n4. ReferenceError: employeeId is not defined",
        "example": "```javascript\n// Global variable modification\nvar globalVar = 'original';\n\nfunction modifyGlobal() {\n    globalVar = 'modified'; // No local declaration, modifies global\n    return;\n}\n\nfunction createLocal() {\n    var globalVar = 'local'; // Local declaration, doesn't affect global\n    return;\n}\n\nconsole.log(globalVar); // 'original'\nmodifyGlobal();\nconsole.log(globalVar); // 'modified'\ncreateLocal();\nconsole.log(globalVar); // 'modified' (unchanged by createLocal)\n```",
        "solution": "**Answer: 2) '123bcd'**\n\n**Explanation:** Inside the function `foo`, there's no local declaration of `employeeId`, so the assignment `employeeId = '123bcd'` modifies the global variable. The function executes, changes the global `employeeId` from 'abc123' to '123bcd', and then the console.log outputs the modified global value.",
        "category": "Scope",
        "difficulty": "Easy"
    },
    {
        "id": 63,
        "question": "## What would be the output of following code?\n\n```javascript\nvar employeeId = 'abc123';\n\nfunction foo() {\n\temployeeId = '123bcd';\n\treturn;\n\n\tfunction employeeId() {}\n}\nfoo();\nconsole.log(employeeId);\n```\n\n1. undefined\n2. '123bcd'\n3. 'abc123'\n4. ReferenceError: employeeId is not defined",
        "example": "```javascript\n// Function declaration hoisting creating local scope\nvar global = 'global value';\n\nfunction test() {\n    global = 'modified'; // This assigns to local function, not global\n    return;\n    \n    function global() {} // Hoisted, creates local variable\n}\n\ntest();\nconsole.log(global); // 'global value' (unchanged)\n\n// Equivalent to:\nfunction test() {\n    function global() {} // Hoisted to top\n    global = 'modified'; // Assigns to local function variable\n    return;\n}\n```",
        "solution": "**Answer: 3) 'abc123'**\n\n**Explanation:** The function declaration `function employeeId() {}` is hoisted to the top of the `foo` function scope, creating a local variable. The assignment `employeeId = '123bcd'` now modifies this local function variable, not the global one. The code effectively becomes:\n\n```javascript\nvar employeeId = 'abc123'; // global\nfunction foo() {\n\tfunction employeeId() {} // hoisted local function\n\temployeeId = '123bcd'; // assigns to local variable\n\treturn;\n}\nfoo();\nconsole.log(employeeId); // still 'abc123' (global unchanged)\n```",
        "category": "Hoisting",
        "difficulty": "Hard"
    },
    {
        "id": 64,
        "question": "## What would be the output of following code?\n\n```javascript\nvar employeeId = 'abc123';\n\nfunction foo() {\n\temployeeId();\n\treturn;\n\n\tfunction employeeId() {\n\t\tconsole.log(typeof employeeId);\n\t}\n}\nfoo();\n```\n\n1. undefined\n2. function\n3. string\n4. ReferenceError: employeeId is not defined",
        "example": "```javascript\n// Function calling itself and checking its own type\nfunction test() {\n    myFunc(); // Call the hoisted function\n    return;\n    \n    function myFunc() {\n        console.log(typeof myFunc); // 'function' - refers to itself\n        console.log(typeof arguments.callee); // 'function' - same thing\n    }\n}\n\ntest(); // Logs: 'function'\n```",
        "solution": "**Answer: 2) function**\n\n**Explanation:** The function declaration `function employeeId() {}` is hoisted to the top of the `foo` function scope. When `employeeId()` is called, it executes the local function. Inside that function, `typeof employeeId` refers to the function itself, so it returns 'function'. The hoisted structure:\n\n```javascript\nfunction foo() {\n\tfunction employeeId() {  // hoisted\n\t\tconsole.log(typeof employeeId); // 'function'\n\t}\n\temployeeId(); // calls the local function\n\treturn;\n}\n```",
        "category": "Hoisting",
        "difficulty": "Hard"
    },
    {
        "id": 65,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction foo() {\n\temployeeId();\n\tvar product = 'Car'; \n\treturn;\n\n\tfunction employeeId() {\n\t\tconsole.log(product);\n\t}\n}\nfoo();\n```\n\n1. undefined\n2. Type Error\n3. 'Car'\n4. ReferenceError: product is not defined",
        "example": "```javascript\n// Variable hoisting with function execution timing\nfunction demo() {\n    helper(); // Called before assignment\n    var message = 'Hello World';\n    return;\n    \n    function helper() {\n        console.log(message); // undefined (declared but not assigned yet)\n    }\n}\n\n// Equivalent to:\nfunction demo() {\n    var message; // hoisted declaration\n    function helper() { // hoisted function\n        console.log(message); // undefined\n    }\n    helper();\n    message = 'Hello World'; // assignment after call\n    return;\n}\n\ndemo(); // Logs: undefined\n```",
        "solution": "**Answer: 1) undefined**\n\n**Explanation:** Both the function declaration `employeeId` and the variable declaration `product` are hoisted to the top. However, the assignment `product = 'Car'` happens at its original position. When `employeeId()` is called (which happens before the assignment), `product` is declared but not yet assigned, so it's `undefined`. The hoisted structure:\n\n```javascript\nfunction foo() {\n\tvar product; // hoisted declaration\n\tfunction employeeId() { // hoisted function\n\t\tconsole.log(product); // undefined\n\t}\n\temployeeId(); // called here\n\tproduct = 'Car'; // assignment happens after the call\n\treturn;\n}\n```",
        "category": "Hoisting",
        "difficulty": "Hard"
    },
    {
        "id": 66,
        "question": "## What would be the output of following code?\n\n```javascript\n(function foo() {\n\tbar();\n\n\tfunction bar() {\n\t\tabc();\n\t\tconsole.log(typeof abc);\n\t}\n\n\tfunction abc() {\n\t\tconsole.log(typeof bar);\n\t}\n}());\n```\n\n1. undefined undefined\n2. Type Error\n3. function function\n4. ReferenceError: bar is not defined",
        "example": "```javascript\n// Multiple function declarations in same scope\n(function() {\n    first(); // Works due to hoisting\n    second(); // Works due to hoisting\n    \n    function first() {\n        console.log('First:', typeof second); // 'function'\n        second();\n    }\n    \n    function second() {\n        console.log('Second:', typeof first); // 'function'\n    }\n}());\n\n// Both functions are hoisted and available throughout the scope\n```",
        "solution": "**Answer: 3) function function**\n\n**Explanation:** Both function declarations `bar` and `abc` are hoisted to the top of the IIFE scope. When executed:\n1. `bar()` is called\n2. Inside `bar`, `abc()` is called first\n3. `abc` logs `typeof bar` which is 'function'\n4. Then `bar` logs `typeof abc` which is 'function'\n\nBoth functions are available throughout the entire scope due to hoisting, so both `typeof` operations return 'function'.",
        "category": "Hoisting",
        "difficulty": "Medium"
    },
    {
        "id": 67,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\t'use strict';\n\n\tvar person = {\n\t\tname: 'John'\n\t};\n\tperson.salary = '10000$';\n\tperson['country'] = 'USA';\n\n\tObject.defineProperty(person, 'phoneNo', {\n\t\tvalue: '8888888888',\n\t\tenumerable: true\n\t})\n\n\tconsole.log(Object.keys(person)); \n})();\n```\n\n1. Type Error\n2. undefined\n3. [\"name\", \"salary\", \"country\", \"phoneNo\"]\n4. [\"name\", \"salary\", \"country\"]",
        "example": "```javascript\n// Object.keys() with enumerable properties\nvar obj = {\n    prop1: 'value1' // enumerable by default\n};\nobj.prop2 = 'value2'; // enumerable by default\nobj['prop3'] = 'value3'; // enumerable by default\n\n// Add enumerable property\nObject.defineProperty(obj, 'prop4', {\n    value: 'value4',\n    enumerable: true\n});\n\n// Add non-enumerable property\nObject.defineProperty(obj, 'prop5', {\n    value: 'value5',\n    enumerable: false\n});\n\nconsole.log(Object.keys(obj)); // ['prop1', 'prop2', 'prop3', 'prop4']\n```",
        "solution": "**Answer: 3) [\"name\", \"salary\", \"country\", \"phoneNo\"]**\n\n**Explanation:** `Object.keys()` returns an array of all enumerable property names of an object. All properties (`name`, `salary`, `country`, and `phoneNo`) are enumerable because:\n- `name` is a regular property (enumerable by default)\n- `salary` is added as a regular property (enumerable by default)\n- `country` is added using bracket notation (enumerable by default)\n- `phoneNo` is explicitly set as enumerable: true using `Object.defineProperty()`",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 68,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\t'use strict';\n\n\tvar person = {\n\t\tname: 'John'\n\t};\n\tperson.salary = '10000$';\n\tperson['country'] = 'USA';\n\n\tObject.defineProperty(person, 'phoneNo', {\n\t\tvalue: '8888888888',\n\t\tenumerable: false\n\t})\n\n\tconsole.log(Object.keys(person)); \n})();\n```\n\n1. Type Error\n2. undefined\n3. [\"name\", \"salary\", \"country\", \"phoneNo\"]\n4. [\"name\", \"salary\", \"country\"]",
        "example": "```javascript\n// Object.keys() excludes non-enumerable properties\nvar obj = {\n    visible: 'I am visible'\n};\n\n// Add non-enumerable property\nObject.defineProperty(obj, 'hidden', {\n    value: 'I am hidden',\n    enumerable: false,\n    writable: true,\n    configurable: true\n});\n\nconsole.log(Object.keys(obj)); // ['visible'] - hidden not included\nconsole.log(obj.hidden); // 'I am hidden' - property exists but not enumerable\n\n// Use Object.getOwnPropertyNames() to see all properties\nconsole.log(Object.getOwnPropertyNames(obj)); // ['visible', 'hidden']\n```",
        "solution": "**Answer: 4) [\"name\", \"salary\", \"country\"]**\n\n**Explanation:** `Object.keys()` only returns enumerable properties. In this case, `phoneNo` is explicitly set as `enumerable: false` using `Object.defineProperty()`, so it won't appear in the result. Only the enumerable properties (`name`, `salary`, `country`) are included in the returned array.",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 69,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar objA = {\n\t\tfoo: 'foo',\n\t\tbar: 'bar'\n\t};\n\tvar objB = {\n\t\tfoo: 'foo',\n\t\tbar: 'bar'\n\t};\n\tconsole.log(objA == objB);\n\tconsole.log(objA === objB);\n}());\n```\n\n1. false true\n2. false false\n3. true false\n4. true true",
        "example": "```javascript\n// Object comparison examples\nvar obj1 = {name: 'John'};\nvar obj2 = {name: 'John'};\nvar obj3 = obj1;\n\nconsole.log(obj1 == obj2);  // false (different objects)\nconsole.log(obj1 === obj2); // false (different objects)\nconsole.log(obj1 == obj3);  // true (same reference)\nconsole.log(obj1 === obj3); // true (same reference)\n\n// Even with identical content, they're different objects\nconsole.log({a: 1} == {a: 1});  // false\nconsole.log({a: 1} === {a: 1}); // false\n```",
        "solution": "**Answer: 2) false false**\n\n**Explanation:** Objects in JavaScript are compared by reference, not by value. Even though `objA` and `objB` have identical properties and values, they are two separate objects stored in different memory locations. Both `==` (loose equality) and `===` (strict equality) compare references for objects, so both return `false` since the objects don't reference the same memory location.",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 70,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar objA = new Object({foo: \"foo\"});\n\tvar objB = new Object({foo: \"foo\"});\n\tconsole.log(objA == objB);\n\tconsole.log(objA === objB);\n}());\n```\n\n1. false true\n2. false false\n3. true false\n4. true true",
        "example": "```javascript\n// Object constructor examples\nvar obj1 = new Object({value: 42});\nvar obj2 = new Object({value: 42});\nvar obj3 = Object.create({value: 42});\n\nconsole.log(obj1 == obj2);  // false (different instances)\nconsole.log(obj1 === obj2); // false (different instances)\nconsole.log(obj1 == obj3);  // false (different instances)\n\n// All create separate objects regardless of constructor method\nconsole.log(typeof obj1); // 'object'\nconsole.log(typeof obj2); // 'object'\nconsole.log(typeof obj3); // 'object'\n```",
        "solution": "**Answer: 2) false false**\n\n**Explanation:** Similar to the previous example, using `new Object()` constructor creates two separate objects in different memory locations. Even though they have identical content, they are different object instances. Object comparison in JavaScript is always by reference, not by value.",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 71,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar objA = Object.create({\n\t\tfoo: 'foo'\n\t});\n\tvar objB = Object.create({\n\t\tfoo: 'foo'\n\t});\n\tconsole.log(objA == objB);\n\tconsole.log(objA === objB);\n}());\n```\n\n1. false true\n2. false false\n3. true false\n4. true true",
        "example": "```javascript\n// Object.create() examples\nvar proto = {name: 'prototype'};\nvar obj1 = Object.create(proto);\nvar obj2 = Object.create(proto);\n\nconsole.log(obj1 == obj2);  // false (different objects)\nconsole.log(obj1 === obj2); // false (different objects)\nconsole.log(obj1.name);     // 'prototype' (inherited)\nconsole.log(obj2.name);     // 'prototype' (inherited)\n\n// They share the same prototype but are different objects\nconsole.log(Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2)); // true\n```",
        "solution": "**Answer: 2) false false**\n\n**Explanation:** `Object.create()` creates a new object with the specified prototype. Both `objA` and `objB` are separate objects with the same prototype `{foo: 'foo'}`. Even though they have identical prototype properties, they are different object instances. Object comparison (`==` and `===`) compares references, not content. Since `objA` and `objB` reference different objects in memory, both comparisons return `false`. JavaScript objects are compared by reference, not by value.",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 72,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar objA = Object.create({\n\t\tfoo: 'foo'\n\t});\n\tvar objB = Object.create(objA);\n\tconsole.log(objA == objB);\n\tconsole.log(objA === objB);\n}());\n```\n\n1. false true\n2. false false\n3. true false\n4. true true",
        "example": "```javascript\n// Prototype chain with Object.create()\nvar grandparent = {level: 'grandparent'};\nvar parent = Object.create(grandparent);\nvar child = Object.create(parent);\n\nconsole.log(parent == child);  // false (different objects)\nconsole.log(parent === child); // false (different objects)\nconsole.log(child.level);      // 'grandparent' (inherited through chain)\n\n// Prototype chain: child → parent → grandparent → Object.prototype\nconsole.log(Object.getPrototypeOf(child) === parent); // true\nconsole.log(Object.getPrototypeOf(parent) === grandparent); // true\n```",
        "solution": "**Answer: 2) false false**\n\n**Explanation:** `objA` is created with prototype `{foo: 'foo'}`. `objB` is created with `objA` as its prototype (prototype chain: objB → objA → {foo: 'foo'}). Even though `objB` inherits from `objA`, they are still different object instances. Object comparison (`==` and `===`) compares references, not inheritance relationships. Both `objA` and `objB` are separate objects in memory, so both comparisons return `false`. Prototype inheritance doesn't affect object identity comparison.",
        "category": "Objects",
        "difficulty": "Hard"
    },
    {
        "id": 73,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar objA = Object.create({\n\t\tfoo: 'foo'\n\t});\n\tvar objB = Object.create(objA);\n\tconsole.log(objA.toString() == objB.toString());\n\tconsole.log(objA.toString() === objB.toString());\n}());\n```\n\n1. false true\n2. false false\n3. true false\n4. true true",
        "example": "```javascript\n// toString() comparison\nvar obj1 = {name: 'test'};\nvar obj2 = {name: 'test'};\nvar obj3 = Object.create({value: 42});\n\nconsole.log(obj1.toString()); // '[object Object]'\nconsole.log(obj2.toString()); // '[object Object]'\nconsole.log(obj3.toString()); // '[object Object]'\n\n// String comparison is value-based\nconsole.log(obj1.toString() == obj2.toString());  // true\nconsole.log(obj1.toString() === obj2.toString()); // true\n\n// But objects themselves are different\nconsole.log(obj1 == obj2);  // false\nconsole.log(obj1 === obj2); // false\n```",
        "solution": "**Answer: 4) true true**\n\n**Explanation:** Both `objA` and `objB` inherit the `toString()` method from `Object.prototype`. When `toString()` is called on objects, it returns the string `\"[object Object]\"`. Since both objects are regular objects, `toString()` returns the same string value. String comparison compares actual values, not references. Both `\"[object Object]\" == \"[object Object]\"` and `\"[object Object]\" === \"[object Object]\"` return `true`. Unlike object comparison, string comparison is value-based.",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 74,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar objA = Object.create({\n\t\tfoo: 'foo'\n\t});\n\tvar objB = objA;\n\tconsole.log(objA == objB);\n\tconsole.log(objA === objB);\n\tconsole.log(objA.toString() == objB.toString());\n\tconsole.log(objA.toString() === objB.toString());\n}());\n```\n\n1. true true true false\n2. true false true true\n3. true true true true\n4. true true false false",
        "example": "```javascript\n// Reference assignment\nvar original = {name: 'John', age: 30};\nvar reference = original; // Same object reference\n\nconsole.log(original == reference);  // true (same reference)\nconsole.log(original === reference); // true (same reference)\nconsole.log(original.name === reference.name); // true (same property)\n\n// Modifying through reference affects original\nreference.name = 'Jane';\nconsole.log(original.name); // 'Jane'\n\n// toString() also returns same result\nconsole.log(original.toString() === reference.toString()); // true\n```",
        "solution": "**Answer: 3) true true true true**\n\n**Explanation:** Here `objB = objA` creates a reference copy, not a new object. Both variables point to the same object in memory. Therefore:\n- `objA == objB` is `true` (same reference)\n- `objA === objB` is `true` (same reference)\n- `objA.toString() == objB.toString()` is `true` (both return the same string value)\n- `objA.toString() === objB.toString()` is `true` (both return the same string value)",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 75,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar objA = Object.create({\n\t\tfoo: 'foo'\n\t});\n\tvar objB = objA;\n\tobjB.foo = 'bar';\n\tconsole.log(objA.foo);\n\tconsole.log(objB.foo);\n}());\n```\n\n1. foo bar\n2. bar bar\n3. foo foo\n4. bar foo",
        "example": "```javascript\n// Property shadowing with shared reference\nvar proto = {name: 'prototype', value: 100};\nvar obj1 = Object.create(proto);\nvar obj2 = obj1; // Same object reference\n\n// Adding own property shadows prototype\nobj2.name = 'own property';\nconsole.log(obj1.name); // 'own property' (same object)\nconsole.log(obj2.name); // 'own property' (same object)\n\n// Prototype property still exists but is shadowed\nconsole.log(Object.getPrototypeOf(obj1).name); // 'prototype'\n```",
        "solution": "**Answer: 2) bar bar**\n\n**Explanation:** `objA` is created with prototype `{foo: 'foo'}`. `objB = objA` creates a reference copy, not a new object (both variables point to the same object). `objB.foo = 'bar'` adds an own property `foo` to the shared object, which shadows the prototype property. Since `objA` and `objB` reference the same object, both see the own property `foo: 'bar'`. The prototype's `foo: 'foo'` is hidden by the own property. Property assignment creates own properties that take precedence over prototype properties.",
        "category": "Objects",
        "difficulty": "Hard"
    },
    {
        "id": 76,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar objA = Object.create({\n\t\tfoo: 'foo'\n\t});\n\tvar objB = objA;\n\tobjB.foo = 'bar';\n\n\tdelete objA.foo;\n\tconsole.log(objA.foo);\n\tconsole.log(objB.foo);\n}());\n```\n\n1. foo bar\n2. bar bar\n3. foo foo\n4. bar foo",
        "example": "```javascript\n// Delete operator with prototype chain\nvar proto = {name: 'from prototype'};\nvar obj = Object.create(proto);\n\n// Add own property\nobj.name = 'own property';\nconsole.log(obj.name); // 'own property' (shadows prototype)\n\n// Delete own property\ndelete obj.name;\nconsole.log(obj.name); // 'from prototype' (falls back to prototype)\n\n// Delete doesn't affect prototype\ndelete obj.name; // Trying to delete prototype property\nconsole.log(obj.name); // 'from prototype' (still there)\n```",
        "solution": "**Answer: 3) foo foo**\n\n**Explanation:** Initially, `objA` has prototype `{foo: 'foo'}`. `objB = objA` makes both variables reference the same object. `objB.foo = 'bar'` creates an own property that shadows the prototype property. `delete objA.foo` removes the own property (not the prototype property). After deletion, property lookup falls back to the prototype chain. Both `objA.foo` and `objB.foo` now access the prototype's `foo: 'foo'`. The `delete` operator only removes own properties, not inherited ones.",
        "category": "Objects",
        "difficulty": "Hard"
    },
    {
        "id": 77,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar objA = {\n\t\tfoo: 'foo'\n\t};\n\tvar objB = objA;\n\tobjB.foo = 'bar';\n\n\tdelete objA.foo;\n\tconsole.log(objA.foo);\n\tconsole.log(objB.foo);\n}());\n```\n\n1. foo bar\n2. undefined undefined\n3. foo foo\n4. undefined bar",
        "example": "```javascript\n// Delete with object literals (no prototype chain)\nvar obj1 = {name: 'John', age: 30};\nvar obj2 = obj1; // Same reference\n\n// Modify property\nobj2.name = 'Jane';\nconsole.log(obj1.name); // 'Jane' (same object)\n\n// Delete property completely\ndelete obj1.name;\nconsole.log(obj1.name); // undefined (property removed)\nconsole.log(obj2.name); // undefined (same object)\nconsole.log('name' in obj1); // false (property doesn't exist)\n```",
        "solution": "**Answer: 2) undefined undefined**\n\n**Explanation:** `objA` is a regular object literal with own property `foo: 'foo'`. `objB = objA` makes both variables reference the same object. `objB.foo = 'bar'` modifies the own property to `foo: 'bar'`. `delete objA.foo` removes the own property completely. Since there's no prototype chain with a `foo` property (unlike objects created with Object.create), property lookup returns `undefined`. Both `objA.foo` and `objB.foo` return `undefined` because the property no longer exists.",
        "category": "Objects",
        "difficulty": "Hard"
    },
    {
        "id": 78,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar array = new Array('100');\n\tconsole.log(array);\n\tconsole.log(array.length);\n}());\n```\n\n1. undefined undefined\n2. [undefined × 100] 100\n3. [\"100\"] 1\n4. ReferenceError: array is not defined",
        "example": "```javascript\n// Array constructor behavior\nconsole.log(new Array(5));        // [empty × 5] - sparse array\nconsole.log(new Array('5'));       // ['5'] - string element\nconsole.log(new Array(1, 2, 3));   // [1, 2, 3] - multiple elements\nconsole.log(new Array('1', '2'));  // ['1', '2'] - multiple string elements\n\n// Key difference: single number vs single string\nconsole.log(new Array(100));       // [empty × 100]\nconsole.log(new Array('100'));      // ['100']\n```",
        "solution": "**Answer: 3) [\"100\"] 1**\n\n**Explanation:** When `new Array()` is called with a single string argument, it creates an array with that string as the only element. The string \"100\" becomes the first (and only) element of the array, so the length is 1. This is different from calling `new Array(100)` with a number, which would create an empty array with 100 slots.",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 79,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar array1 = [];\n\tvar array2 = new Array(100);\n\tvar array3 = new Array(['1',2,'3',4,5.6]);\n\tconsole.log(array1);\n\tconsole.log(array2);\n\tconsole.log(array3);\n\tconsole.log(array3.length);\n}());\n```\n\n1. [] [] [Array[5]] 1\n2. [] [undefined × 100] Array[5] 1\n3. [] [] ['1',2,'3',4,5.6] 5\n4. [] [] [Array[5]] 5",
        "example": "```javascript\n// Different Array constructor behaviors\nconsole.log([]);                    // [] - empty array\nconsole.log(new Array(3));          // [empty × 3] - sparse array\nconsole.log(new Array([1,2,3]));     // [[1,2,3]] - nested array\nconsole.log(new Array(1,2,3));       // [1,2,3] - multiple elements\n\n// Single argument behavior\nconsole.log(new Array(5).length);    // 5 (sparse array)\nconsole.log(new Array([1,2,3]).length); // 1 (array as single element)\n```",
        "solution": "**Answer: 1) [] [] [Array[5]] 1**\n\n**Explanation:**\n- `array1 = []` creates an empty array with length 0\n- `array2 = new Array(100)` creates a sparse array with 100 empty slots (not undefined values)\n- `array3 = new Array(['1',2,'3',4,5.6])` creates an array with ONE element (the entire array as a single element)\n- When `Array()` constructor receives a single argument that's an array, it treats the array as one element\n- `console.log(array2)` displays `[]` in most browsers (empty sparse array), not `[undefined × 100]`\n- `array3.length` is 1 because it contains one element (which happens to be an array)\n- Key concept: `new Array(n)` vs `new Array(element)` behavior difference",
        "category": "Arrays",
        "difficulty": "Hard"
    },
    {
        "id": 80,
        "question": "## What would be the output of following code?\n\n```javascript\n(function () {\n  var array = new Array('a', 'b', 'c', 'd', 'e');\n  array[10] = 'f';\n  delete array[10];\n  console.log(array.length);\n}());\n```\n\n1. 11\n2. 5\n3. 6\n4. undefined",
        "example": "```javascript\n// Array length behavior\nvar arr = ['a', 'b', 'c'];\nconsole.log(arr.length); // 3\n\n// Setting high index extends length\narr[10] = 'x';\nconsole.log(arr.length); // 11\nconsole.log(arr); // ['a', 'b', 'c', empty × 7, 'x']\n\n// Delete doesn't change length\ndelete arr[10];\nconsole.log(arr.length); // 11 (unchanged)\nconsole.log(arr[10]); // undefined\n```",
        "solution": "**Answer: 1) 11**\n\n**Explanation:** When you assign a value to `array[10]`, the array length automatically extends to 11 (indices 0-10). The `delete` operator removes the value at index 10 but doesn't change the array's length property. After deletion, `array[10]` becomes `undefined`, but the length remains 11. Array length in JavaScript is always one more than the highest index that has been assigned.",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 81,
        "question": "## What would be the output of following code?\n\n```javascript\n(function(){\n\tvar animal = ['cow','horse'];\n\t\tanimal.push('cat');\n\t\tanimal.push('dog','rat','goat');\n\t\tconsole.log(animal.length);\n})();\n```\n\n1. 4\n2. 5\n3. 6\n4. undefined",
        "example": "```javascript\n// push() method examples\nvar fruits = ['apple', 'banana'];\nconsole.log(fruits.length); // 2\n\n// Single element\nfruits.push('orange');\nconsole.log(fruits); // ['apple', 'banana', 'orange']\nconsole.log(fruits.length); // 3\n\n// Multiple elements\nfruits.push('grape', 'kiwi', 'mango');\nconsole.log(fruits); // ['apple', 'banana', 'orange', 'grape', 'kiwi', 'mango']\nconsole.log(fruits.length); // 6\n```",
        "solution": "**Answer: 3) 6**\n\n**Explanation:**\n- Initial array: `['cow','horse']` has length 2\n- First `push('cat')` adds one element: `['cow','horse','cat']` - length becomes 3\n- Second `push('dog','rat','goat')` adds three elements at once: `['cow','horse','cat','dog','rat','goat']`\n- Final length is 6\n- Key concept: `array.push()` can accept multiple arguments and adds all of them to the array\n- `push()` returns the new length of the array after adding elements\n- The array becomes: `['cow','horse','cat','dog','rat','goat']`",
        "category": "Arrays",
        "difficulty": "Easy"
    },
    {
        "id": 82,
        "question": "## What would be the output of following code?\n\n```javascript\n(function(){\n\tvar animal = ['cow','horse'];\n\t\tanimal.push('cat');\n\t\tanimal.unshift('dog','rat','goat');\n\t\tconsole.log(animal);\n})();\n```\n\n1. [ 'dog', 'rat', 'goat', 'cow', 'horse', 'cat' ]\n2. [ 'cow', 'horse', 'cat', 'dog', 'rat', 'goat' ]\n3. Type Error\n4. undefined",
        "example": "```javascript\n// push() vs unshift() methods\nvar arr = [1, 2, 3];\nconsole.log(arr); // [1, 2, 3]\n\n// push() adds to end\narr.push(4, 5);\nconsole.log(arr); // [1, 2, 3, 4, 5]\n\n// unshift() adds to beginning\narr.unshift(-1, 0);\nconsole.log(arr); // [-1, 0, 1, 2, 3, 4, 5]\n\n// Order matters: elements are added in the order provided\nvar test = [];\ntest.unshift('a', 'b', 'c');\nconsole.log(test); // ['a', 'b', 'c']\n```",
        "solution": "**Answer: 1) [ 'dog', 'rat', 'goat', 'cow', 'horse', 'cat' ]**\n\n**Explanation:** Array's `push()` adds elements to the end, while `unshift()` adds elements to the beginning. Starting with `['cow','horse']`, `push('cat')` makes it `['cow','horse','cat']`, then `unshift('dog','rat','goat')` adds the three elements to the beginning, resulting in `['dog','rat','goat','cow','horse','cat']`.",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 83,
        "question": "## What would be the output of following code?\n\n```javascript\n(function(){\n\tvar array = [1,2,3,4,5];\n\tconsole.log(array.indexOf(2));\n\tconsole.log([{name: 'John'},{name : 'John'}].indexOf({name:'John'}));\n\tconsole.log([[1],[2],[3],[4]].indexOf([3]));\n\tconsole.log(\"abcdefgh\".indexOf('e'));\n})();\n```\n\n1. 1 -1 -1 4\n2. 1 0 -1 4\n3. 1 -1 -1 -1\n4. 1 undefined -1 4",
        "example": "```javascript\n// indexOf() with different data types\nvar arr = [1, 'hello', true, null];\nconsole.log(arr.indexOf(1));      // 0\nconsole.log(arr.indexOf('hello')); // 1\nconsole.log(arr.indexOf(true));   // 2\n\n// Reference comparison for objects\nvar obj = {name: 'John'};\nvar arrWithObj = [obj, {name: 'Jane'}];\nconsole.log(arrWithObj.indexOf(obj)); // 0 (same reference)\nconsole.log(arrWithObj.indexOf({name: 'John'})); // -1 (different reference)\n\n// String indexOf()\nconsole.log('JavaScript'.indexOf('Script')); // 4\nconsole.log('JavaScript'.indexOf('script')); // -1 (case sensitive)\n```",
        "solution": "**Answer: 1) 1 -1 -1 4**\n\n**Explanation:**\n- `array.indexOf(2)` returns `1` (the index where 2 is found in the array)\n- `[{name: 'John'},{name : 'John'}].indexOf({name:'John'})` returns `-1` because `indexOf` uses strict equality (`===`) to compare elements. The new object `{name:'John'}` is a different reference than the existing objects in the array\n- `[[1],[2],[3],[4]].indexOf([3])` returns `-1` for the same reason - the new array `[3]` is a different reference than the existing `[3]` array in the array\n- `\"abcdefgh\".indexOf('e')` returns `4` (the index where 'e' is found in the string)\n\nKey concept: `indexOf()` uses strict equality comparison, so objects and arrays are compared by reference, not by value.",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 84,
        "question": "## What would be the output of following code?\n\n```javascript\n(function(){\n\tvar array = [1,2,3,4,5,1,2,3,4,5,6];\n\tconsole.log(array.indexOf(2));\n\tconsole.log(array.indexOf(2,3));\n\tconsole.log(array.indexOf(2,10));\n})();\n```\n\n1. 1 -1 -1\n2. 1 6 -1\n3. 1 1 -1\n4. 1 undefined undefined",
        "example": "```javascript\n// indexOf() with fromIndex parameter\nvar numbers = [1, 2, 3, 2, 4, 2, 5];\n//           [0, 1, 2, 3, 4, 5, 6] - indices\n\nconsole.log(numbers.indexOf(2));    // 1 (first occurrence)\nconsole.log(numbers.indexOf(2, 2)); // 3 (search from index 2)\nconsole.log(numbers.indexOf(2, 4)); // 5 (search from index 4)\nconsole.log(numbers.indexOf(2, 6)); // -1 (search from index 6)\nconsole.log(numbers.indexOf(2, 7)); // -1 (beyond array length)\n\n// Negative fromIndex\nconsole.log(numbers.indexOf(2, -3)); // 5 (equivalent to fromIndex 4)\n```",
        "solution": "**Answer: 2) 1 6 -1**\n\n**Explanation:** `indexOf(searchElement, fromIndex)` searches for an element starting from a specific index:\n- `array.indexOf(2)` finds the first occurrence of 2 at index `1`\n- `array.indexOf(2,3)` searches for 2 starting from index 3, finds it at index `6` (second occurrence)\n- `array.indexOf(2,10)` searches starting from index 10, but there's no 2 after index 10, so returns `-1`",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 85,
        "question": "## What would be the output of following code?\n\n```javascript\n(function(){\n\tvar numbers = [2,3,4,8,9,11,13,12,16];\n\tvar even = numbers.filter(function(element, index){\n\t\treturn element % 2 === 0; \n\t});\n\tconsole.log(even);\n\n\tvar containsDivisibleby3 = numbers.some(function(element, index){\n\t\treturn element % 3 === 0;\n\t});\n\n\tconsole.log(containsDivisibleby3);\t\n})();\n```\n\n1. [ 2, 4, 8, 12, 16 ] [ 0, 3, 0, 0, 9, 0, 12]\n2. [ 2, 4, 8, 12, 16 ] [ 3, 9, 12]\n3. [ 2, 4, 8, 12, 16 ] true\n4. [ 2, 4, 8, 12, 16 ] false",
        "example": "```javascript\n// filter() and some() examples\nvar numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// filter() returns new array with elements that pass the test\nvar evens = numbers.filter(n => n % 2 === 0);\nconsole.log(evens); // [2, 4, 6, 8, 10]\n\n// some() returns boolean - true if at least one element passes\nvar hasOdd = numbers.some(n => n % 2 === 1);\nconsole.log(hasOdd); // true\n\nvar hasNegative = numbers.some(n => n < 0);\nconsole.log(hasNegative); // false\n\n// every() returns boolean - true if all elements pass\nvar allPositive = numbers.every(n => n > 0);\nconsole.log(allPositive); // true\n```",
        "solution": "**Answer: 3) [ 2, 4, 8, 12, 16 ] true**\n\n**Explanation:**\n- `filter()` creates a new array with elements that pass the test. Elements divisible by 2 (even numbers) are: 2, 4, 8, 12, 16\n- `some()` returns `true` if at least one element passes the test. In the array, several numbers (3, 9, 12) are divisible by 3, so `some()` returns `true`",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 86,
        "question": "## What would be the output of following code?\n\n```javascript\n(function(){\n\tvar containers = [2,0,false,\"\", '12', true];\n\tvar containers = containers.filter(Boolean);\n\tconsole.log(containers);\n\tvar containers = containers.filter(Number);\n\tconsole.log(containers);\n\tvar containers = containers.filter(String);\n\tconsole.log(containers);\n\tvar containers = containers.filter(Object);\n\tconsole.log(containers);\t\t\n})();\n```\n\n1. [ 2, '12', true ] [ 2, '12', true ] [ 2, '12', true ] [ 2, '12', true ]\n2. [false, true] [ 2 ] ['12'] [ ]\n3. [2,0,false,\"\", '12', true] [2,0,false,\"\", '12', true] [2,0,false,\"\", '12', true] [2,0,false,\"\", '12', true]\n4. [ 2, '12', true ] [ 2, '12', true, false ] [ 2, '12', true,false ] [ 2, '12', true,false]",
        "example": "```javascript\n// Constructor functions as filter callbacks\nvar mixed = [0, 1, '', 'hello', false, true, null, undefined];\n\n// Boolean constructor filters truthy values\nconsole.log(mixed.filter(Boolean)); // [1, 'hello', true]\n\n// Number constructor converts and filters\nconsole.log([1, '2', true, false].filter(Number)); // [1, '2', true]\n\n// String constructor converts and filters\nconsole.log([0, 1, '', 'hello'].filter(String)); // [1, 'hello']\n\n// Object constructor filters object-convertible values\nconsole.log([null, undefined, 0, 1, ''].filter(Object)); // [0, 1, '']\n```",
        "solution": "**Answer: 1) [ 2, '12', true ] [ 2, '12', true ] [ 2, '12', true ] [ 2, '12', true ]**\n\n**Explanation:** When constructor functions are used as filter callbacks, they convert each element and use the result as a truthy/falsy check:\n\n1. `filter(Boolean)` removes falsy values: `0`, `false`, `\"\"` → keeps `[2, '12', true]`\n2. `filter(Number)` converts each to number, all remaining elements convert to truthy numbers → keeps all `[2, '12', true]`\n3. `filter(String)` converts each to string, all convert to truthy strings → keeps all `[2, '12', true]`\n4. `filter(Object)` converts each to object, all convert to truthy objects → keeps all `[2, '12', true]`",
        "category": "Arrays",
        "difficulty": "Hard"
    },
    {
        "id": 87,
        "question": "## What would be the output of following code?\n\n```javascript\n(function(){\n\tvar list = ['foo','bar','john','ritz'];\n\t    console.log(list.slice(1));\t\n\t    console.log(list.slice(1,3));\n\t    console.log(list.slice());\n\t    console.log(list.slice(2,2));\n\t    console.log(list);\t\t\t\t\n})();\n```\n\n1. [ 'bar', 'john', 'ritz' ] [ 'bar', 'john' ] [ 'foo', 'bar', 'john', 'ritz' ] [] [ 'foo', 'bar', 'john', 'ritz' ]\n2. [ 'bar', 'john', 'ritz' ] [ 'bar', 'john','ritz ] [ 'foo', 'bar', 'john', 'ritz' ] [] [ 'foo', 'bar', 'john', 'ritz' ]\n3. [ 'john', 'ritz' ] [ 'bar', 'john' ] [ 'foo', 'bar', 'john', 'ritz' ] [] [ 'foo', 'bar', 'john', 'ritz' ]\n4. [ 'foo' ] [ 'bar', 'john' ] [ 'foo', 'bar', 'john', 'ritz' ] [] [ 'foo', 'bar', 'john', 'ritz' ]",
        "example": "```javascript\n// slice() method examples\nvar fruits = ['apple', 'banana', 'cherry', 'date', 'elderberry'];\n//           [   0   ,    1    ,    2    ,   3  ,      4      ]\n\nconsole.log(fruits.slice(1));     // ['banana', 'cherry', 'date', 'elderberry']\nconsole.log(fruits.slice(1, 3));  // ['banana', 'cherry'] (end index exclusive)\nconsole.log(fruits.slice(-2));    // ['date', 'elderberry'] (negative start)\nconsole.log(fruits.slice(2, -1)); // ['cherry', 'date'] (negative end)\nconsole.log(fruits.slice());      // ['apple', 'banana', 'cherry', 'date', 'elderberry'] (copy all)\nconsole.log(fruits);              // ['apple', 'banana', 'cherry', 'date', 'elderberry'] (original unchanged)\n```",
        "solution": "**Answer: 1) [ 'bar', 'john', 'ritz' ] [ 'bar', 'john' ] [ 'foo', 'bar', 'john', 'ritz' ] [] [ 'foo', 'bar', 'john', 'ritz' ]**\n\n**Explanation:** `slice()` returns a shallow copy of a portion of an array without modifying the original:\n- `slice(1)` returns elements from index 1 to end: ['bar', 'john', 'ritz']\n- `slice(1,3)` returns elements from index 1 to 3 (exclusive): ['bar', 'john']\n- `slice()` with no parameters returns a copy of the entire array\n- `slice(2,2)` returns empty array [] (start and end are the same)\n- Original array remains unchanged throughout",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 88,
        "question": "## What would be the output of following code?\n\n```javascript\n(function(){\n\tvar list = ['foo','bar','john'];\n\t    console.log(list.splice(1));\t\t\n\t    console.log(list.splice(1,2));\n\t    console.log(list);\t\t\t\n})();\n```\n\n1. [ 'bar', 'john' ] [] [ 'foo' ]\n2. [ 'bar', 'john' ] [] [ 'bar', 'john' ]\n3. [ 'bar', 'john' ] [ 'bar', 'john' ] [ 'bar', 'john' ]\n4. [ 'bar', 'john' ] [] []",
        "example": "```javascript\n// splice() method examples - modifies original array\nvar fruits = ['apple', 'banana', 'cherry', 'date'];\n\n// Remove elements from index 1 to end\nvar removed1 = fruits.splice(1);\nconsole.log(removed1); // ['banana', 'cherry', 'date']\nconsole.log(fruits);   // ['apple'] (original modified)\n\n// Reset array\nfruits = ['apple', 'banana', 'cherry', 'date'];\n\n// Remove 2 elements starting from index 1\nvar removed2 = fruits.splice(1, 2);\nconsole.log(removed2); // ['banana', 'cherry']\nconsole.log(fruits);   // ['apple', 'date'] (original modified)\n\n// Add elements without removing\nfruits.splice(1, 0, 'orange', 'grape');\nconsole.log(fruits); // ['apple', 'orange', 'grape', 'date']\n```",
        "solution": "**Answer: 1) [ 'bar', 'john' ] [] [ 'foo' ]**\n\n**Explanation:** `splice()` modifies the original array by removing/adding elements and returns the removed elements:\n- `list.splice(1)` removes elements from index 1 to end, returns ['bar', 'john'], list becomes ['foo']\n- `list.splice(1,2)` tries to remove 2 elements starting from index 1, but only 'foo' remains, so nothing is removed, returns []\n- Final list remains ['foo'] since no elements were removed in the second splice",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 89,
        "question": "## What would be the output of following code?\n\n```javascript\n(function(){\n\tvar arrayNumb = [2, 8, 15, 16, 23, 42];\n\tarrayNumb.sort();\n\tconsole.log(arrayNumb);\n})();\n```\n\n1. [2, 8, 15, 16, 23, 42]\n2. [42, 23, 26, 15, 8, 2]\n3. [ 15, 16, 2, 23, 42, 8 ]\n4. [ 2, 8, 15, 16, 23, 42 ]",
        "example": "```javascript\n// sort() method behavior\nvar numbers1 = [10, 5, 40, 25, 1000, 1];\nnumbers1.sort();\nconsole.log(numbers1); // [1, 10, 1000, 25, 40, 5] - lexicographic sort\n\n// Correct numeric sorting\nvar numbers2 = [10, 5, 40, 25, 1000, 1];\nnumbers2.sort((a, b) => a - b);\nconsole.log(numbers2); // [1, 5, 10, 25, 40, 1000] - numeric sort\n\n// String sorting (default behavior)\nvar strings = ['banana', 'apple', 'cherry'];\nstrings.sort();\nconsole.log(strings); // ['apple', 'banana', 'cherry']\n\n// Character by character comparison\nconsole.log('15' < '2');  // true (string comparison)\nconsole.log('15' < '8');  // true (string comparison)\n```",
        "solution": "**Answer: 3) [ 15, 16, 2, 23, 42, 8 ]**\n\n**Explanation:** By default, `sort()` converts elements to strings and sorts them lexicographically (alphabetically). Numbers are converted to strings: \"2\", \"8\", \"15\", \"16\", \"23\", \"42\". In string comparison: \"15\" < \"16\" < \"2\" < \"23\" < \"42\" < \"8\" because string comparison is character by character. To sort numerically, you need to provide a comparison function: `sort((a, b) => a - b)`.",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 90,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction funcA(){\n\tconsole.log(\"funcA \", this);\n\t(function innerFuncA1(){\n\t\tconsole.log(\"innerFunc1\", this);\n\t\t(function innerFunA11(){\n\t\t\tconsole.log(\"innerFunA11\", this);\n\t\t})();\n\t})();\n}\n\t\nconsole.log(funcA());\n```\n\n1. funcA  Window {...} innerFunc1 Window {...} innerFunA11 Window {...}\n2. undefined\n3. Type Error\n4. ReferenceError: this is not defined",
        "example": "```javascript\n// 'this' context in different function calls\nfunction regular() {\n    console.log('Regular function this:', this); // Window in non-strict mode\n}\n\nvar obj = {\n    method: function() {\n        console.log('Method this:', this); // obj\n        \n        function inner() {\n            console.log('Inner function this:', this); // Window in non-strict mode\n        }\n        inner();\n    }\n};\n\nregular();    // this = Window\nobj.method(); // this = obj for method, Window for inner function\n\n// In strict mode:\n'use strict';\nfunction strictFunc() {\n    console.log('Strict this:', this); // undefined\n}\nstrictFunc();\n```",
        "solution": "**Answer: 1) funcA  Window {...} innerFunc1 Window {...} innerFunA11 Window {...}**\n\n**Explanation:** In non-strict mode, when functions are called without an explicit context (not as methods of an object), `this` defaults to the global object (Window in browsers). All three functions - `funcA`, `innerFuncA1`, and `innerFunA11` - are called as regular functions, so `this` refers to the Window object in all cases. The function also returns `undefined` since there's no explicit return statement.",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 91,
        "question": "## What would be the output of following code?\n\n```javascript\nvar obj = {\n\tmessage: \"Hello\",\n\tinnerMessage: !(function() {\n\t\tconsole.log(this.message);\n\t})()\n};\n\t\nconsole.log(obj.innerMessage);\n```\n\n1. ReferenceError: this.message is not defined\n2. undefined\n3. Type Error\n4. undefined true",
        "example": "```javascript\n// IIFE context examples\nvar globalVar = 'Global';\n\nvar obj = {\n    localVar: 'Local',\n    method: !(function() {\n        console.log(this.globalVar); // undefined (global context)\n        console.log(this.localVar);  // undefined (not in obj context)\n        return false; // IIFE returns false\n    })()\n};\n\nconsole.log(obj.method); // true (because !false = true)\n\n// Comparison with regular method\nvar obj2 = {\n    localVar: 'Local',\n    method: function() {\n        console.log(this.localVar); // 'Local' (obj context)\n    }\n};\n```",
        "solution": "**Answer: 4) undefined true**\n\n**Explanation:** The IIFE (Immediately Invoked Function Expression) executes in the global context, so `this` refers to the Window object. `this.message` is `undefined` (no global message property). The IIFE returns `undefined`, and `!undefined` evaluates to `true`. So `obj.innerMessage` becomes `true`, and `console.log(this.message)` outputs `undefined`.",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 92,
        "question": "## What would be the output of following code?\n\n```javascript\nvar obj = {\n\tmessage: \"Hello\",\n\tinnerMessage: function() {\n\t\treturn this.message;\n\t}\n};\n\t\nconsole.log(obj.innerMessage());\n```\n\n1. Hello\n2. undefined\n3. Type Error\n4. ReferenceError: this.message is not defined",
        "example": "```javascript\n// Method context examples\nvar person = {\n    name: 'John',\n    greet: function() {\n        return 'Hello, ' + this.name; // this refers to person object\n    }\n};\n\nconsole.log(person.greet()); // 'Hello, John'\n\n// Different calling contexts\nvar greetFunc = person.greet;\nconsole.log(greetFunc()); // 'Hello, undefined' (this refers to global)\n\n// Using call to set context\nconsole.log(greetFunc.call(person)); // 'Hello, John'\n```",
        "solution": "**Answer: 1) Hello**\n\n**Explanation:** When `obj.innerMessage()` is called, the function is invoked as a method of the `obj` object. In this context, `this` refers to the `obj` object, so `this.message` equals `\"Hello\"`. The function returns this value, which is then logged to the console.",
        "category": "Functions",
        "difficulty": "Easy"
    },
    {
        "id": 93,
        "question": "## What would be the output of following code?\n\n```javascript\nvar obj = {\n  message: 'Hello',\n  innerMessage: function () {\n    (function () {\n      console.log(this.message);\n    }());\n  }\n};\nconsole.log(obj.innerMessage());\n```\n\n1. Type Error\n2. Hello\n3. undefined\n4. ReferenceError: this.message is not defined",
        "example": "```javascript\n// Nested function context\nvar obj = {\n    value: 'Object Value',\n    method: function() {\n        console.log('Outer this:', this.value); // 'Object Value'\n        \n        function innerFunc() {\n            console.log('Inner this:', this.value); // undefined (global context)\n        }\n        innerFunc();\n        \n        // Solution: capture this reference\n        var self = this;\n        function innerFuncFixed() {\n            console.log('Fixed inner:', self.value); // 'Object Value'\n        }\n        innerFuncFixed();\n    }\n};\n\nobj.method();\n```",
        "solution": "**Answer: 3) undefined**\n\n**Explanation:** Although `obj.innerMessage()` is called as a method (so `this` would be `obj` in the outer function), the inner IIFE is called as a regular function, not as a method. In the inner function, `this` refers to the global object (Window), where `message` is undefined. The outer method doesn't return anything, so `console.log(obj.innerMessage())` also logs `undefined`.",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 94,
        "question": "## What would be the output of following code?\n\n```javascript\nvar obj = {\n  message: 'Hello',\n  innerMessage: function () {\n  \tvar self = this;\n    (function () {\n      console.log(self.message);\n    }());\n  }\n};\nconsole.log(obj.innerMessage());\n```\n\n1. Type Error\n2. 'Hello'\n3. undefined\n4. ReferenceError: self.message is not defined",
        "example": "```javascript\n// Common patterns for preserving 'this' context\nvar obj = {\n    name: 'MyObject',\n    values: [1, 2, 3],\n    \n    // Problem: losing context in callbacks\n    processValues: function() {\n        this.values.forEach(function(value) {\n            console.log(this.name, value); // undefined, value (this is global)\n        });\n    },\n    \n    // Solution 1: self pattern\n    processValuesSelf: function() {\n        var self = this;\n        this.values.forEach(function(value) {\n            console.log(self.name, value); // 'MyObject', value\n        });\n    },\n    \n    // Solution 2: arrow function (ES6)\n    processValuesArrow: function() {\n        this.values.forEach((value) => {\n            console.log(this.name, value); // 'MyObject', value\n        });\n    }\n};\n```",
        "solution": "**Answer: 2) 'Hello'**\n\n**Explanation:** This is a common pattern to preserve the context of `this` in inner functions. The variable `self` captures the reference to the `obj` object (since `obj.innerMessage()` was called as a method). The inner IIFE can access `self` through closure, so `self.message` equals \"Hello\". The method returns `undefined`, so the outer `console.log` also prints `undefined`.",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 95,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction myFunc(){\n\tconsole.log(this.message);\n}\nmyFunc.message = \"Hi John\";\n\t\nconsole.log(myFunc());\n```\n\n1. Type Error\n2. 'Hi John'\n3. undefined\n4. ReferenceError: this.message is not defined",
        "example": "```javascript\n// Function properties vs this context\nfunction greet() {\n    console.log('this.name:', this.name);\n    console.log('greet.name:', greet.name); // function's own name property\n    console.log('greet.customProp:', greet.customProp);\n}\n\ngreet.customProp = 'Custom Property';\ngreet.name = 'Modified Name'; // This won't work, name is read-only\n\n// Regular function call\ngreet(); // this.name: undefined, greet.name: 'greet', greet.customProp: 'Custom Property'\n\n// Method call\nvar obj = { name: 'Object', method: greet };\nobj.method(); // this.name: 'Object', greet.name: 'greet', greet.customProp: 'Custom Property'\n```",
        "solution": "**Answer: 3) undefined**\n\n**Explanation:** When `myFunc()` is called as a regular function, `this` refers to the global object (Window), not to the function object itself. Although `myFunc.message` is set to \"Hi John\" (functions are objects and can have properties), `this.message` looks for a `message` property on the global object, which is `undefined`. The function also returns `undefined` since there's no return statement.",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 96,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction myFunc(){\n\tconsole.log(myFunc.message);\n}\nmyFunc.message = \"Hi John\";\n\t\nconsole.log(myFunc());\n```\n\n1. Type Error\n2. 'Hi John'\n3. undefined\n4. ReferenceError: this.message is not defined",
        "example": "```javascript\n// Direct function property access\nfunction calculator() {\n    console.log('Operation:', calculator.operation);\n    console.log('Version:', calculator.version);\n    return calculator.lastResult || 0;\n}\n\n// Adding properties to function\ncalculator.operation = 'add';\ncalculator.version = '1.0';\ncalculator.lastResult = 42;\n\nconsole.log(calculator()); // Operation: add, Version: 1.0, Returns: 42\n\n// Functions are objects, so we can add any properties\ncalculator.history = [];\ncalculator.reset = function() {\n    this.lastResult = 0;\n    this.history = [];\n};\n```",
        "solution": "**Answer: 2) 'Hi John'**\n\n**Explanation:** Unlike the previous example, here we directly reference `myFunc.message` instead of `this.message`. Since functions are objects in JavaScript, we can assign properties to them. `myFunc.message` is set to \"Hi John\" and directly accessed by name, so it prints \"Hi John\". The function still returns `undefined`.",
        "category": "Functions",
        "difficulty": "Easy"
    },
    {
        "id": 97,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction myFunc() {\n  myFunc.message = 'Hi John';\n  console.log(myFunc.message);\n}\nconsole.log(myFunc());\n```\n\n1. Type Error\n2. 'Hi John'\n3. undefined\n4. ReferenceError: this.message is not defined",
        "example": "```javascript\n// Dynamic property assignment during execution\nfunction counter() {\n    counter.count = (counter.count || 0) + 1;\n    console.log('Call #' + counter.count);\n    return counter.count;\n}\n\nconsole.log(counter()); // Call #1, Returns: 1\nconsole.log(counter()); // Call #2, Returns: 2\nconsole.log(counter()); // Call #3, Returns: 3\n\n// Properties persist between calls\nfunction memoize() {\n    if (!memoize.cache) {\n        memoize.cache = {};\n    }\n    memoize.cache['key'] = 'cached value';\n    console.log('Cache:', memoize.cache);\n}\n\nmemoize(); // Cache: {key: 'cached value'}\n```",
        "solution": "**Answer: 2) 'Hi John'**\n\n**Explanation:** This function sets its own property `myFunc.message` during execution and then immediately accesses it. When `myFunc()` is called, it first sets `myFunc.message = 'Hi John'`, then logs that value. The function prints \"Hi John\" and returns `undefined`. The outer `console.log` then prints `undefined`.",
        "category": "Functions",
        "difficulty": "Easy"
    },
    {
        "id": 98,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction myFunc(param1,param2) {\n  console.log(myFunc.length);\n}\nconsole.log(myFunc());\nconsole.log(myFunc(\"a\",\"b\"));\nconsole.log(myFunc(\"a\",\"b\",\"c\",\"d\"));\n```\n\n1. 2 2 2\n2. 0 2 4\n3. undefined\n4. ReferenceError",
        "example": "```javascript\n// Function.length examples\nfunction func1() {} \nconsole.log(func1.length); // 0\n\nfunction func2(a) {} \nconsole.log(func2.length); // 1\n\nfunction func3(a, b, c) {} \nconsole.log(func3.length); // 3\n\n// Default parameters not counted\nfunction func4(a, b = 5) {} \nconsole.log(func4.length); // 1\n\n// Rest parameters not counted\nfunction func5(a, ...rest) {} \nconsole.log(func5.length); // 1\n\n// vs arguments.length (runtime)\nfunction test(a, b) {\n    console.log('Declared params:', test.length);     // Always 2\n    console.log('Actual args:', arguments.length);   // Varies by call\n}\n\ntest();           // Declared: 2, Actual: 0\ntest(1);          // Declared: 2, Actual: 1\ntest(1, 2, 3);    // Declared: 2, Actual: 3\n```",
        "solution": "**Answer: 1) 2 2 2**\n\n**Explanation:** The `length` property of a function returns the number of formal parameters defined in the function signature (declaration). This is a **static property** determined at function definition time, not at runtime. `myFunc(param1, param2)` is defined with exactly **2 formal parameters**, so `myFunc.length` will always return `2`. This value is fixed at function definition time and never changes regardless of how many arguments are actually passed when calling the function.",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 99,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction myFunc() {\n  console.log(arguments.length);\n}\nconsole.log(myFunc());\nconsole.log(myFunc(\"a\",\"b\"));\nconsole.log(myFunc(\"a\",\"b\",\"c\",\"d\"));\n```\n\n1. 2 2 2\n2. 0 2 4\n3. undefined\n4. ReferenceError",
        "example": "```javascript\n// arguments.length vs function.length\nfunction flexibleFunc(required) {\n    console.log('Function length (declared params):', flexibleFunc.length);\n    console.log('Arguments length (actual args):', arguments.length);\n    console.log('Arguments:', Array.from(arguments));\n    return 'processed';\n}\n\nconsole.log('=== Call with no args ===');\nflexibleFunc(); // Function: 1, Arguments: 0\n\nconsole.log('=== Call with 2 args ===');\nflexibleFunc('a', 'b'); // Function: 1, Arguments: 2\n\nconsole.log('=== Call with 5 args ===');\nflexibleFunc(1, 2, 3, 4, 5); // Function: 1, Arguments: 5\n\n// Practical use case\nfunction sum() {\n    var total = 0;\n    for (var i = 0; i < arguments.length; i++) {\n        total += arguments[i];\n    }\n    return total;\n}\n\nconsole.log(sum(1, 2, 3)); // 6\nconsole.log(sum(1, 2, 3, 4, 5)); // 15\n```",
        "solution": "**Answer: 2) 0 2 4**\n\n**Explanation:** The `arguments` object contains all arguments actually passed to the function, regardless of the formal parameters. Its `length` property reflects the actual number of arguments: `myFunc()` - no arguments passed: `arguments.length = 0`, `myFunc(\"a\",\"b\")` - 2 arguments passed: `arguments.length = 2`, `myFunc(\"a\",\"b\",\"c\",\"d\")` - 4 arguments passed: `arguments.length = 4`. Each call also returns `undefined`.",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 100,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction Person(name, age){\n\tthis.name = name || \"John\";\n\tthis.age = age || 24;\n\tthis.displayName = function(){\n\t\tconsole.log(this.name);\n\t}\n}\n\nPerson.name = \"John\";\nPerson.displayName = function(){\n\tconsole.log(this.name);\n}\n\nvar person1 = new Person('John');\n\tperson1.displayName();\n\tPerson.displayName();\n```\n\n1. John Person\n2. John John\n3. John undefined\n4. John John",
        "example": "```javascript\n// Instance vs Static methods\nfunction Car(brand) {\n    this.brand = brand;\n    this.start = function() {\n        console.log(this.brand + ' is starting'); // Instance method\n    };\n}\n\n// Static method on constructor\nCar.getInfo = function() {\n    console.log('This is the Car constructor: ' + this.name); // 'Car'\n};\n\nvar myCar = new Car('Toyota');\nmyCar.start();     // 'Toyota is starting' (this = myCar instance)\nCar.getInfo();     // 'This is the Car constructor: Car' (this = Car function)\n\n// Function.name property\nconsole.log(Car.name);           // 'Car' (built-in property)\nconsole.log(myCar.constructor.name); // 'Car'\n\n// Different contexts\nvar staticMethod = Car.getInfo;\nstaticMethod();    // 'This is the Car constructor: Car' (still refers to Car)\n```",
        "solution": "**Answer: 1) John Person**\n\n**Explanation:** When `person1.displayName()` is called, it's an instance method where `this` refers to the `person1` object, so `this.name` equals \"John\". When `Person.displayName()` is called, it's a static method where `this` refers to the `Person` function object itself. Every function in JavaScript has a built-in `name` property containing the function's name, so `this.name` equals \"Person\".",
        "category": "Objects",
        "difficulty": "Hard"
    },
    {
        "id": 101,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction passWordMngr() {\n\tvar password = '12345678';\n\tthis.userName = 'John';\n\treturn {\n\t\tpwd: password\n\t};\n}\n// Block End\nvar userInfo = passWordMngr();\nconsole.log(userInfo.pwd);\nconsole.log(userInfo.userName);\n```\n\n1. 12345678 Window\n2. 12345678 John\n3. 12345678 undefined\n4. undefined undefined",
        "example": "```javascript\n// Function call vs constructor call\nfunction DataManager() {\n    var privateData = 'secret';\n    this.publicData = 'public';\n    \n    return {\n        getData: function() {\n            return privateData; // Closure access\n        }\n    };\n}\n\n// Regular function call\nvar result1 = DataManager();\nconsole.log(result1.getData());    // 'secret'\nconsole.log(result1.publicData);   // undefined (not in returned object)\nconsole.log(window.publicData);    // 'public' (this was global)\n\n// Constructor call\nvar result2 = new DataManager();\nconsole.log(result2.getData());    // 'secret'\nconsole.log(result2.publicData);   // undefined (constructor return overrides)\n\n// Without explicit return\nfunction SimpleManager() {\n    this.data = 'stored';\n    // No return statement\n}\n\nvar simple1 = SimpleManager();     // undefined (regular call)\nvar simple2 = new SimpleManager(); // {data: 'stored'} (constructor call)\n```",
        "solution": "**Answer: 3) 12345678 undefined**\n\n**Explanation:** The function `passWordMngr()` is called as a regular function (not with `new` or as a method), so `this` refers to the global object. However, the function returns an object `{pwd: password}`, which becomes the value of `userInfo`. The returned object only has a `pwd` property (with access to the local `password` variable due to closure), but no `userName` property. Therefore, `userInfo.pwd` is '12345678' and `userInfo.userName` is `undefined`.",
        "category": "Scopes",
        "difficulty": "Medium"
    },
    {
        "id": 102,
        "question": "## What would be the output of following code?\n\n```javascript\nvar employeeId = 'aq123';\nfunction Employee() {\n  this.employeeId = 'bq1uy';\n}\nconsole.log(Employee.employeeId);\n```\n\n1. Reference Error\n2. aq123\n3. bq1uy\n4. undefined",
        "example": "```javascript\n// Function object properties vs instance properties\nfunction Worker() {\n    this.id = 'instance-id';     // Instance property\n    this.type = 'instance-type'; // Instance property\n}\n\n// Properties on function object itself\nWorker.id = 'static-id';\nWorker.category = 'static-category';\n\n// Accessing function properties\nconsole.log(Worker.id);        // 'static-id'\nconsole.log(Worker.category);  // 'static-category'\nconsole.log(Worker.type);      // undefined (not on function object)\n\n// Creating instance\nvar worker1 = new Worker();\nconsole.log(worker1.id);       // 'instance-id'\nconsole.log(worker1.type);     // 'instance-type'\nconsole.log(worker1.category); // undefined (not on instance)\n\n// Function vs instance are separate objects\nWorker.newProp = 'added later';\nconsole.log(Worker.newProp);   // 'added later'\nconsole.log(worker1.newProp);  // undefined\n```",
        "solution": "**Answer: 4) undefined**\n\n**Explanation:** `Employee.employeeId` tries to access a property directly on the function object itself (functions are objects in JavaScript). The function `Employee` doesn't have an `employeeId` property defined on it. The `this.employeeId = 'bq1uy'` only sets a property on instances created with `new Employee()`, not on the function object itself. Therefore, `Employee.employeeId` returns `undefined`.",
        "category": "Scopes",
        "difficulty": "Medium"
    },
    {
        "id": 103,
        "question": "## What would be the output of following code?\n\n```javascript\nvar employeeId = 'aq123';\n\nfunction Employee() {\n\tthis.employeeId = 'bq1uy';\n}\nconsole.log(new Employee().employeeId);\nEmployee.prototype.employeeId = 'kj182';\nEmployee.prototype.JobId = '1BJKSJ';\nconsole.log(new Employee().JobId);\nconsole.log(new Employee().employeeId);\n```\n\n1. bq1uy 1BJKSJ bq1uy undefined\n2. bq1uy 1BJKSJ bq1uy\n3. bq1uy 1BJKSJ kj182\n4. undefined 1BJKSJ kj182",
        "example": "```javascript\n// Property shadowing and prototype chain\nfunction Product(name) {\n    this.name = name;           // Own property\n    this.category = 'default';  // Own property\n}\n\n// Add to prototype\nProduct.prototype.name = 'prototype-name';\nProduct.prototype.category = 'prototype-category';\nProduct.prototype.brand = 'prototype-brand';\n\nvar product = new Product('laptop');\n\n// Property resolution order: own properties first\nconsole.log(product.name);     // 'laptop' (own property shadows prototype)\nconsole.log(product.category); // 'default' (own property shadows prototype)\nconsole.log(product.brand);    // 'prototype-brand' (from prototype)\n\n// Checking property location\nconsole.log(product.hasOwnProperty('name'));     // true\nconsole.log(product.hasOwnProperty('brand'));    // false\nconsole.log('brand' in product);                 // true (found in prototype)\n\n// Delete own property to reveal prototype\ndelete product.category;\nconsole.log(product.category); // 'prototype-category' (now from prototype)\n```",
        "solution": "**Answer: 2) bq1uy 1BJKSJ bq1uy**\n\n**Explanation:** This demonstrates JavaScript's property resolution mechanism and prototype chain behavior. When `new Employee()` is called, the constructor creates an own property `this.employeeId = 'bq1uy'` on each instance. Even though `Employee.prototype.employeeId = 'kj182'` is added later, the own property shadows (hides) the prototype property. For `JobId`, since there's no own property, JavaScript looks up the prototype chain and finds it on `Employee.prototype`. Property resolution order: Own Properties → Constructor.prototype → Object.prototype → null.",
        "category": "Scopes",
        "difficulty": "Hard"
    },
    {
        "id": 104,
        "question": "## What would be the output of following code?\n\n```javascript\nvar employeeId = 'aq123';\n(function Employee() {\n\ttry {\n\t\tthrow 'foo123';\n\t} catch (employeeId) {\n\t\tconsole.log(employeeId);\n\t}\n\tconsole.log(employeeId);\n}());\n```\n\n1. foo123 aq123\n2. foo123 foo123\n3. aq123 aq123\n4. foo123 undefined",
        "example": "```javascript\n// Catch block scope and variable shadowing\nvar outerVar = 'outer';\n\nfunction testScope() {\n    var localVar = 'local';\n    \n    try {\n        throw 'exception-value';\n    } catch (outerVar) {  // Parameter shadows outer variable\n        console.log('In catch - outerVar:', outerVar);     // 'exception-value'\n        console.log('In catch - localVar:', localVar);     // 'local'\n        \n        var innerVar = 'inner';\n        console.log('In catch - innerVar:', innerVar);     // 'inner'\n    }\n    \n    console.log('After catch - outerVar:', outerVar);     // 'outer' (original value)\n    console.log('After catch - localVar:', localVar);     // 'local'\n    console.log('After catch - innerVar:', innerVar);     // 'inner' (var is function-scoped)\n}\n\ntestScope();\nconsole.log('Global - outerVar:', outerVar);           // 'outer'\n\n// Block scope with let/const\ntry {\n    throw 'error';\n} catch (blockVar) {\n    let blockLet = 'block';\n    console.log(blockVar); // 'error'\n}\n// console.log(blockLet); // ReferenceError: blockLet is not defined\n```",
        "solution": "**Answer: 1) foo123 aq123**\n\n**Explanation:** Inside the `catch` block, the parameter `employeeId` creates a new local scope that shadows the global `employeeId`. The first `console.log(employeeId)` inside the catch block refers to the caught exception value 'foo123'. The second `console.log(employeeId)` is outside the catch block, so it refers to the global `employeeId` which is 'aq123'. The catch parameter only exists within the catch block scope.",
        "category": "Scopes",
        "difficulty": "Medium"
    },
    {
        "id": 105,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar greet = 'Hello World';\n\tvar toGreet = [].filter.call(greet, function(element, index) {\n\t\treturn index > 5;\n\t});\n\tconsole.log(toGreet);\n}());\n```\n\n1. Hello World\n2. undefined\n3. World\n4. [ 'W', 'o', 'r', 'l', 'd' ]",
        "example": "```javascript\n// Using array methods on string with call/apply\nvar text = 'JavaScript';\n\n// filter with call\nvar consonants = [].filter.call(text, function(char, index) {\n    return !'aeiou'.includes(char.toLowerCase());\n});\nconsole.log(consonants); // ['J', 'v', 'S', 'c', 'r', 'p', 't']\n\n// map with call\nvar upperCased = [].map.call(text, function(char, index) {\n    return char.toUpperCase();\n});\nconsole.log(upperCased); // ['J', 'A', 'V', 'A', 'S', 'C', 'R', 'I', 'P', 'T']\n\n// slice with call\nvar sliced = [].slice.call(text, 2, 5);\nconsole.log(sliced); // ['v', 'a', 'S']\n\n// Modern alternatives\nvar modernFilter = Array.from(text).filter(char => !'aeiou'.includes(char.toLowerCase()));\nvar spread = [...text].slice(2, 5);\nconsole.log(modernFilter); // ['J', 'v', 'S', 'c', 'r', 'p', 't']\nconsole.log(spread);       // ['v', 'a', 'S']\n```",
        "solution": "**Answer: 4) [ 'W', 'o', 'r', 'l', 'd' ]**\n\n**Explanation:** `[].filter.call(greet, callback)` uses the `call` method to apply the array `filter` method to a string. Strings are array-like objects, so `filter` can iterate over each character. The callback function `return index > 5` filters characters at indices greater than 5. In \"Hello World\" (indices 0-10), characters at indices 6-10 are 'W', 'o', 'r', 'l', 'd', which form the returned array.",
        "category": "Call, Apply, Bind",
        "difficulty": "Medium"
    },
    {
        "id": 106,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar fooAccount = {\n\t\tname: 'John',\n\t\tamount: 4000,\n\t\tdeductAmount: function(amount) {\n\t\t\tthis.amount -= amount;\n\t\t\treturn 'Total amount left in account: ' + this.amount;\n\t\t}\n\t};\n\tvar barAccount = {\n\t\tname: 'John',\n\t\tamount: 6000\n\t};\n\tvar withdrawAmountBy = function(totalAmount) {\n\t\treturn fooAccount.deductAmount.bind(barAccount, totalAmount);\n\t};\n\tconsole.log(withdrawAmountBy(400)());\n\tconsole.log(withdrawAmountBy(300)());\n}());\n```\n\n1. Total amount left in account: 5600 Total amount left in account: 5300\n2. undefined undefined\n3. Total amount left in account: 3600 Total amount left in account: 3300\n4. Total amount left in account: 5600 Total amount left in account: 5600",
        "example": "```javascript\n// bind() method example\nvar account = {\n    balance: 1000,\n    withdraw: function(amount) {\n        this.balance -= amount;\n        return 'Remaining balance: ' + this.balance;\n    }\n};\n\nvar savingsAccount = { balance: 5000 };\n\n// Create bound function\nvar withdrawFromSavings = account.withdraw.bind(savingsAccount);\n\nconsole.log(withdrawFromSavings(200)); // 'Remaining balance: 4800'\nconsole.log(withdrawFromSavings(300)); // 'Remaining balance: 4500'\n\n// Pre-filled arguments with bind\nvar withdraw500 = account.withdraw.bind(savingsAccount, 500);\nconsole.log(withdraw500()); // 'Remaining balance: 4000'\n```",
        "solution": "**Answer: 1) Total amount left in account: 5600 Total amount left in account: 5300**\n\n**Explanation:** `bind()` creates a new function with a bound context and pre-filled arguments:\n- `withdrawAmountBy(400)` returns a bound function with `this` set to `barAccount` and `amount` set to 400\n- First call: `barAccount.amount` (6000) - 400 = 5600\n- Second call: `barAccount.amount` (5600) - 300 = 5300\nThe `barAccount` object's amount property is being modified progressively.",
        "category": "Call, Apply, Bind",
        "difficulty": "Medium"
    },
    {
        "id": 107,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar fooAccount = {\n\t\tname: 'John',\n\t\tamount: 4000,\n\t\tdeductAmount: function(amount) {\n\t\t\tthis.amount -= amount;\n\t\t\treturn this.amount;\n\t\t}\n\t};\n\tvar barAccount = {\n\t\tname: 'John',\n\t\tamount: 6000\n\t};\n\tvar withdrawAmountBy = function(totalAmount) {\n\t\treturn fooAccount.deductAmount.apply(barAccount, [totalAmount]);\n\t};\n\tconsole.log(withdrawAmountBy(400));\n\tconsole.log(withdrawAmountBy(300));\n\tconsole.log(withdrawAmountBy(200));\n}());\n```\n\n1. 5600 5300 5100\n2. 3600 3300 3100\n3. 5600 3300 5100\n4. undefined undefined undefined",
        "example": "```javascript\n// apply() method example\nvar mathUtils = {\n    multiply: function(a, b, c) {\n        return a * b * c;\n    }\n};\n\nvar calculator = {\n    result: 0,\n    calculate: function(operation, numbers) {\n        this.result = operation.apply(null, numbers);\n        return this.result;\n    }\n};\n\nvar numbers = [2, 3, 4];\nconsole.log(calculator.calculate(mathUtils.multiply, numbers)); // 24\n\n// Using apply with different context\nvar counter = { value: 0 };\nvar incrementer = {\n    add: function(a, b, c) {\n        this.value += a + b + c;\n        return this.value;\n    }\n};\n\nconsole.log(incrementer.add.apply(counter, [1, 2, 3])); // 6\nconsole.log(counter.value); // 6\n```",
        "solution": "**Answer: 1) 5600 5300 5100**\n\n**Explanation:** `apply()` immediately calls the function with the specified context and arguments:\n- `apply(barAccount, [totalAmount])` sets `this` to `barAccount` and passes the amount argument\n- First call: `barAccount.amount` (6000) - 400 = 5600\n- Second call: `barAccount.amount` (5600) - 300 = 5300\n- Third call: `barAccount.amount` (5300) - 200 = 5100\nEach call modifies and returns the updated `barAccount.amount`.",
        "category": "Call, Apply, Bind",
        "difficulty": "Medium"
    },
    {
        "id": 108,
        "question": "## What would be the output of following code?\n\n```javascript\n(function() {\n\tvar fooAccount = {\n\t\tname: 'John',\n\t\tamount: 6000,\n\t\tdeductAmount: function(amount) {\n\t\t\tthis.amount -= amount;\n\t\t\treturn this.amount;\n\t\t}\n\t};\n\tvar barAccount = {\n\t\tname: 'John',\n\t\tamount: 4000\n\t};\n\tvar withdrawAmountBy = function(totalAmount) {\n\t\treturn fooAccount.deductAmount.call(barAccount, totalAmount);\n\t};\n\tconsole.log(withdrawAmountBy(400));\n\tconsole.log(withdrawAmountBy(300));\n\tconsole.log(withdrawAmountBy(200));\n}());\n```\n\n1. 5600 5300 5100\n2. 3600 3300 3100\n3. 5600 3300 5100\n4. undefined undefined undefined",
        "example": "```javascript\n// call() method example\nvar person1 = {\n    name: 'John',\n    greet: function(greeting, punctuation) {\n        return greeting + ' ' + this.name + punctuation;\n    }\n};\n\nvar person2 = { name: 'Jane' };\n\n// Using call to invoke person1's method with person2's context\nconsole.log(person1.greet.call(person2, 'Hello', '!')); // 'Hello Jane!'\n\n// vs apply (array of arguments)\nconsole.log(person1.greet.apply(person2, ['Hi', '.'])); // 'Hi Jane.'\n\n// Direct method call for comparison\nconsole.log(person1.greet('Hey', '?')); // 'Hey John?'\n```",
        "solution": "**Answer: 2) 3600 3300 3100**\n\n**Explanation:** `call()` immediately invokes the function with the specified context and individual arguments:\n- `call(barAccount, totalAmount)` sets `this` to `barAccount` (amount: 4000) and passes the amount\n- First call: `barAccount.amount` (4000) - 400 = 3600\n- Second call: `barAccount.amount` (3600) - 300 = 3300\n- Third call: `barAccount.amount` (3300) - 200 = 3100\nNote: `barAccount` starts with 4000, not 6000 like `fooAccount`.",
        "category": "Call, Apply, Bind",
        "difficulty": "Medium"
    },
    {
        "id": 109,
        "question": "## What would be the output of following code?\n\n```javascript\n(function greetNewCustomer() {\n\tconsole.log('Hello ' + this.name);\n}.bind({\n\tname: 'John'\n})());\n```\n\n1. Hello John\n2. Reference Error\n3. Window\n4. undefined",
        "example": "```javascript\n// IIFE with bind example\n(function() {\n    console.log('Regular IIFE this:', this); // Window/global object\n})();\n\n// Named IIFE with bind\n(function namedIIFE() {\n    console.log('Bound IIFE this.value:', this.value);\n}.bind({ value: 'custom context' })());\n\n// Comparison with regular function binding\nfunction regularFunc() {\n    console.log('Regular function this.prop:', this.prop);\n}\n\nvar boundFunc = regularFunc.bind({ prop: 'bound value' });\nboundFunc(); // 'Regular function this.prop: bound value'\n\n// Arrow function comparison (lexical this)\nvar obj = {\n    value: 'object value',\n    method: function() {\n        (function() {\n            console.log('Inner function this:', this); // Window/global\n        })();\n        \n        (() => {\n            console.log('Arrow function this.value:', this.value); // 'object value'\n        })();\n    }\n};\n```",
        "solution": "**Answer: 1) Hello John**\n\n**Explanation:** This is a named IIFE (Immediately Invoked Function Expression) with `bind()`:\n- `.bind({name: 'John'})` creates a new function with `this` bound to the object `{name: 'John'}`\n- The trailing `()` immediately invokes this bound function\n- Inside the function, `this.name` refers to 'John' from the bound object\n- Output: \"Hello John\"",
        "category": "Call, Apply, Bind",
        "difficulty": "Medium"
    },
    {
        "id": 110,
        "question": "## Suggest your question!",
        "example": "```javascript\n// This is a placeholder for community-contributed questions\n// Users can suggest their own JavaScript interview questions\n\n// Example suggestion format:\nfunction exampleQuestion() {\n    // Your creative JavaScript code here\n    console.log('What would be the output?');\n}\n\n// Common areas for suggestions:\n// - Closures and scope\n// - Prototype chains\n// - Async programming\n// - ES6+ features\n// - Event handling\n// - Type coercion\n```",
        "solution": "**This is an open question for community contributions.**\n\n**How to contribute:**\n1. Think of an interesting JavaScript concept that could trip up developers\n2. Write code that demonstrates edge cases or unexpected behavior\n3. Provide multiple choice answers\n4. Include a detailed explanation\n\n**Good question characteristics:**\n- Tests understanding of core JavaScript concepts\n- Has a non-obvious answer that requires careful thinking\n- Teaches something valuable about the language\n- Covers common interview topics or real-world scenarios",
        "category": "Community",
        "difficulty": "Variable"
    },
    {
        "id": 111,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction getDataFromServer(apiUrl){\n    var name = \"John\";\n\treturn {\n\t\tthen : function(fn){\n\t\t\tfn(name);\n\t\t}\n\t}\n}\n\ngetDataFromServer('www.google.com').then(function(name){\n\tconsole.log(name);\n});\n```\n\n1. John\n2. undefined\n3. Reference Error\n4. fn is not defined",
        "example": "```javascript\n// Promise-like pattern example\nfunction createThenable(value) {\n    return {\n        then: function(callback) {\n            setTimeout(() => {\n                callback(value);\n            }, 100);\n        }\n    };\n}\n\n// Usage\ncreateThenable('Hello World').then(function(data) {\n    console.log(data); // 'Hello World' (after 100ms)\n});\n\n// Comparison with real Promise\nPromise.resolve('Promise value').then(function(data) {\n    console.log(data); // 'Promise value'\n});\n\n// Chaining example with closure\nfunction makeCounter() {\n    var count = 0;\n    return {\n        then: function(callback) {\n            callback(++count);\n        }\n    };\n}\n\nvar counter = makeCounter();\ncounter.then(x => console.log(x)); // 1\ncounter.then(x => console.log(x)); // 2\n```",
        "solution": "**Answer: 1) John**\n\n**Explanation:** `getDataFromServer()` returns an object with a `then` method that accepts a callback function `fn`. When `.then()` is called with the callback `function(name){console.log(name);}`, it executes `fn(name)` where `name` is \"John\" from the closure. The callback receives \"John\" as an argument and logs it. This pattern mimics a simple Promise-like structure.",
        "category": "Callback Functions",
        "difficulty": "Medium"
    },
    {
        "id": 112,
        "question": "## What would be the output of following code?\n\n```javascript\n(function(){\n\tvar arrayNumb = [2, 8, 15, 16, 23, 42];\n\tArray.prototype.sort = function(a,b){\n\t\treturn a - b;\n\t};\n\tarrayNumb.sort();\n\tconsole.log(arrayNumb);\n})();\n\n(function(){\n\tvar numberArray = [2, 8, 15, 16, 23, 42];\n\tnumberArray.sort(function(a,b){\n\t\tif(a == b){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn a < b ? -1 : 1;\n\t\t}\n\t});\n\tconsole.log(numberArray);\n})();\n\n(function(){\n\tvar numberArray = [2, 8, 15, 16, 23, 42];\n\tnumberArray.sort(function(a,b){\n\t\treturn a-b;\n\t});\n\tconsole.log(numberArray);\n})();\n```\n\n1. [ 2, 8, 15, 16, 23, 42 ] [ 2, 8, 15, 16, 23, 42 ] [ 2, 8, 15, 16, 23, 42 ]\n2. undefined undefined undefined\n3. [42, 23, 16, 15, 8, 2] [42, 23, 16, 15, 8, 2] [42, 23, 16, 15, 8, 2]\n4. Reference Error",
        "example": "```javascript\n// Different sorting approaches\nvar numbers = [10, 5, 40, 25, 1000, 1];\n\n// Default sort (lexicographic)\nnumbers.sort();\nconsole.log(numbers); // [1, 10, 1000, 25, 40, 5]\n\n// Numeric sort (ascending)\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers); // [1, 5, 10, 25, 40, 1000]\n\n// Numeric sort (descending)\nnumbers.sort((a, b) => b - a);\nconsole.log(numbers); // [1000, 40, 25, 10, 5, 1]\n\n// Custom comparison function\nnumbers.sort(function(a, b) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n});\nconsole.log(numbers); // [1, 5, 10, 25, 40, 1000]\n\n// Array.prototype modification (doesn't work as expected)\nvar originalSort = Array.prototype.sort;\nArray.prototype.sort = function(compareFn) {\n    console.log('Custom sort called');\n    return originalSort.call(this, compareFn);\n};\n```",
        "solution": "**Answer: 1) [ 2, 8, 15, 16, 23, 42 ] [ 2, 8, 15, 16, 23, 42 ] [ 2, 8, 15, 16, 23, 42 ]**\n\n**Explanation:** All three approaches produce the same result because:\n\n1. **IIFE 1**: Attempts to override `Array.prototype.sort` but the built-in sort method has its own internal implementation. The array is already sorted.\n\n2. **IIFE 2**: Uses explicit comparison logic that implements ascending sort (returns -1 for a < b, 1 for a > b, 0 for a == b).\n\n3. **IIFE 3**: Uses the standard numeric sort comparison function (a - b).\n\nSince the input array `[2, 8, 15, 16, 23, 42]` is already sorted in ascending order, and all approaches implement ascending sort logic, they all produce the same output.",
        "category": "Callback Functions",
        "difficulty": "Hard"
    },
    {
        "id": 113,
        "question": "## What would be the output of following code?\n\n```javascript\n(function(){\n\tfunction sayHello(){\n\t\tvar name = \"Hi John\";\n\t\treturn \n\t\t{\n\t\t\tfullName: name\n\t\t}\n\t}\n\tconsole.log(sayHello().fullName);\n})();\n```\n\n1. Hi John\n2. undefined\n3. Reference Error\n4. Uncaught TypeError: Cannot read property 'fullName' of undefined",
        "example": "```javascript\n// Automatic Semicolon Insertion (ASI) examples\nfunction problematicReturn() {\n    return  // ASI inserts semicolon here\n    {\n        value: 'This object is unreachable'\n    };\n}\nconsole.log(problematicReturn()); // undefined\n\n// Correct way\nfunction correctReturn() {\n    return {\n        value: 'This works fine'\n    };\n}\nconsole.log(correctReturn().value); // 'This works fine'\n\n// Another ASI example\nfunction increment() {\n    var x = 5\n    return x\n    ++  // This becomes a separate statement\n}\nconsole.log(increment()); // 5 (not 6)\n\n// Line break after return with parentheses\nfunction arrayReturn() {\n    return (\n        ['item1', 'item2', 'item3']\n    );\n}\nconsole.log(arrayReturn()); // ['item1', 'item2', 'item3']\n```",
        "solution": "**Answer: 4) Uncaught TypeError: Cannot read property 'fullName' of undefined**\n\n**Explanation:** Due to JavaScript's Automatic Semicolon Insertion (ASI), a semicolon is automatically inserted after the `return` statement, making it `return;` which returns `undefined`. The object literal on the next lines becomes unreachable code. Since `sayHello()` returns `undefined`, attempting to access `undefined.fullName` throws a TypeError.",
        "category": "Return Statement",
        "difficulty": "Medium"
    },
    {
        "id": 114,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction getNumber(){\n\treturn (2,4,5);\n}\n\nvar numb = getNumber();\nconsole.log(numb);\n```\n\n1. 5\n2. undefined\n3. 2\n4. (2,4,5)",
        "example": "```javascript\n// Comma operator examples\nconsole.log((1, 2, 3)); // 3\nconsole.log((true, false, 'hello')); // 'hello'\n\n// Comma operator in for loops\nfor (var i = 0, j = 10; i < 5; i++, j--) {\n    console.log(i, j);\n}\n// 0 10\n// 1 9\n// 2 8\n// 3 7\n// 4 6\n\n// Comma operator with function calls\nfunction sideEffect(x) {\n    console.log('Side effect:', x);\n    return x * 2;\n}\n\nvar result = (sideEffect(1), sideEffect(2), sideEffect(3));\n// Output: Side effect: 1, Side effect: 2, Side effect: 3\nconsole.log(result); // 6\n\n// Assignment with comma operator\nvar a, b;\nvar x = (a = 1, b = 2, a + b);\nconsole.log(x); // 3\nconsole.log(a); // 1\nconsole.log(b); // 2\n```",
        "solution": "**Answer: 1) 5**\n\n**Explanation:** The comma operator `(2,4,5)` evaluates each expression from left to right and returns the value of the last expression. So `(2,4,5)` evaluates to `5`. The parentheses around the comma expressions ensure they're treated as a single expression, and the function returns the result of the comma operator, which is `5`.",
        "category": "Return Statement",
        "difficulty": "Medium"
    },
    {
        "id": 115,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction getNumber(){\n\treturn;\n}\n\nvar numb = getNumber();\nconsole.log(numb);\n```\n\n1. null\n2. undefined\n3. \"\"\n4. 0",
        "example": "```javascript\n// Different return scenarios\nfunction noReturn() {\n    // No return statement\n}\nconsole.log(noReturn()); // undefined\n\nfunction emptyReturn() {\n    return;\n}\nconsole.log(emptyReturn()); // undefined\n\nfunction explicitUndefined() {\n    return undefined;\n}\nconsole.log(explicitUndefined()); // undefined\n\nfunction returnValue() {\n    return 42;\n}\nconsole.log(returnValue()); // 42\n\n// Early return\nfunction conditionalReturn(x) {\n    if (x > 0) {\n        return 'positive';\n    }\n    return 'non-positive';\n}\nconsole.log(conditionalReturn(5));  // 'positive'\nconsole.log(conditionalReturn(-1)); // 'non-positive'\n\n// Constructor function returns\nfunction Constructor() {\n    this.prop = 'value';\n    return; // Ignored in constructor calls\n}\nvar obj = new Constructor();\nconsole.log(obj.prop); // 'value'\n```",
        "solution": "**Answer: 2) undefined**\n\n**Explanation:** When a function has a `return;` statement without a value, or when a function reaches the end without an explicit return statement, it implicitly returns `undefined`. In this case, `return;` explicitly returns `undefined`, so `numb` gets the value `undefined`.",
        "category": "Return Statement",
        "difficulty": "Easy"
    },
    {
        "id": 116,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction mul(x){\n\treturn function(y){\n\t\treturn [x*y, function(z){\n\t\t\treturn x*y + z;\n\t\t}];\n\t}\n}\n\nconsole.log(mul(2)(3)[0]);\nconsole.log(mul(2)(3)[1](4));\n```\n\n1. 6, 10\n2. undefined undefined\n3. Reference Error\n4. 10, 6",
        "example": "```javascript\n// Closures and higher-order functions\nfunction createMultiplier(factor) {\n    return function(number) {\n        return number * factor;\n    };\n}\n\nvar double = createMultiplier(2);\nvar triple = createMultiplier(3);\n\nconsole.log(double(5)); // 10\nconsole.log(triple(4)); // 12\n\n// Currying example\nfunction curry(fn) {\n    return function(a) {\n        return function(b) {\n            return function(c) {\n                return fn(a, b, c);\n            };\n        };\n    };\n}\n\nfunction add(a, b, c) {\n    return a + b + c;\n}\n\nvar curriedAdd = curry(add);\nconsole.log(curriedAdd(1)(2)(3)); // 6\n\n// Factory function returning array with methods\nfunction createCalculator(initial) {\n    return [\n        initial,\n        function(x) { return initial + x; },\n        function(x) { return initial * x; }\n    ];\n}\n\nvar calc = createCalculator(10);\nconsole.log(calc[0]);    // 10\nconsole.log(calc[1](5)); // 15\nconsole.log(calc[2](3)); // 30\n```",
        "solution": "**Answer: 1) 6, 10**\n\n**Explanation:** This demonstrates closures and higher-order functions:\n- `mul(2)(3)` returns an array `[6, function(z){return 2*3 + z;}]`\n- `mul(2)(3)[0]` accesses the first element: `2*3 = 6`\n- `mul(2)(3)[1](4)` accesses the second element (a function) and calls it with `4`: `2*3 + 4 = 10`\nBoth the inner function and the returned function maintain access to the outer variables `x` and `y` through closures.",
        "category": "Return Statement",
        "difficulty": "Hard"
    },
    {
        "id": 117,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction mul(x) {\n\treturn function(y) {\n\t\treturn {\n\t\t\tresult: x * y,\n\t\t\tsum: function(z) {\n\t\t\t\treturn x * y + z;\n\t\t\t}\n\t\t};\n\t};\n}\nconsole.log(mul(2)(3).result);\nconsole.log(mul(2)(3).sum(4));\n```\n\n1. 6, 10\n2. undefined undefined\n3. Reference Error\n4. 10, 6",
        "example": "```javascript\n// Factory pattern with methods\nfunction createPerson(name, age) {\n    return {\n        name: name,\n        age: age,\n        greet: function() {\n            return 'Hello, I am ' + name + ' and I am ' + age + ' years old';\n        },\n        haveBirthday: function() {\n            age++;\n            return 'Happy birthday! Now I am ' + age;\n        }\n    };\n}\n\nvar person = createPerson('John', 25);\nconsole.log(person.name);           // 'John'\nconsole.log(person.greet());        // 'Hello, I am John and I am 25 years old'\nconsole.log(person.haveBirthday()); // 'Happy birthday! Now I am 26'\n\n// Module pattern\nfunction createCounter() {\n    var count = 0;\n    return {\n        value: count,\n        increment: function() {\n            return ++count;\n        },\n        decrement: function() {\n            return --count;\n        },\n        reset: function() {\n            count = 0;\n            return count;\n        }\n    };\n}\n\nvar counter = createCounter();\nconsole.log(counter.increment()); // 1\nconsole.log(counter.increment()); // 2\nconsole.log(counter.value);       // 0 (original value, not updated)\n```",
        "solution": "**Answer: 1) 6, 10**\n\n**Explanation:** This is a curried function returning an object with a computed property and a method:\n- `mul(2)(3)` returns `{ result: 6, sum: function(z) { return 6 + z; } }`\n- `mul(2)(3).result` accesses the `result` property: `2 * 3 = 6`\n- `mul(2)(3).sum(4)` calls the `sum` method: `6 + 4 = 10`\nThe inner function and method maintain access to `x` and `y` through closures.",
        "category": "Return Statement",
        "difficulty": "Hard"
    },
    {
        "id": 118,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction mul(x) {\n\treturn function(y) {\n\t\treturn function(z) {\n\t\t\treturn function(w) {\n\t\t\t\treturn function(p) {\n\t\t\t\t\treturn x * y * z * w * p;\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t};\n}\nconsole.log(mul(2)(3)(4)(5)(6));\n```\n\n1. 720\n2. undefined\n3. Reference Error\n4. Type Error",
        "example": "```javascript\n// Currying with multiple levels\nfunction curriedAdd(a) {\n    return function(b) {\n        return function(c) {\n            return function(d) {\n                return a + b + c + d;\n            };\n        };\n    };\n}\n\nconsole.log(curriedAdd(1)(2)(3)(4)); // 10\n\n// Generic curry function\nfunction curry(fn) {\n    return function curried(...args) {\n        if (args.length >= fn.length) {\n            return fn.apply(this, args);\n        } else {\n            return function(...args2) {\n                return curried.apply(this, args.concat(args2));\n            };\n        }\n    };\n}\n\nfunction multiply(a, b, c, d, e) {\n    return a * b * c * d * e;\n}\n\nvar curriedMultiply = curry(multiply);\nconsole.log(curriedMultiply(1)(2)(3)(4)(5)); // 120\nconsole.log(curriedMultiply(1, 2)(3, 4, 5)); // 120\nconsole.log(curriedMultiply(1, 2, 3, 4, 5)); // 120\n\n// Practical currying example\nfunction createElement(tag) {\n    return function(attributes) {\n        return function(children) {\n            return { tag, attributes, children };\n        };\n    };\n}\n\nvar div = createElement('div');\nvar divWithClass = div({ className: 'container' });\nvar element = divWithClass(['Hello World']);\nconsole.log(element); // { tag: 'div', attributes: { className: 'container' }, children: ['Hello World'] }\n```",
        "solution": "**Answer: 1) 720**\n\n**Explanation:** This is a nested closure chain (curried function) with 5 levels:\n- `mul(2)` returns a function that expects `y`\n- `mul(2)(3)` returns a function that expects `z`\n- `mul(2)(3)(4)` returns a function that expects `w`\n- `mul(2)(3)(4)(5)` returns a function that expects `p`\n- `mul(2)(3)(4)(5)(6)` finally executes the innermost function\n- Result: `2 * 3 * 4 * 5 * 6 = 720`\nEach function maintains access to all outer scope variables through closures.",
        "category": "Return Statement",
        "difficulty": "Hard"
    },
    {
        "id": 119,
        "question": "## What would be the output of following code?\n\n```javascript\nfunction getName1(){\n\tconsole.log(this.name);\n}\n\nObject.prototype.getName2 = () =>{\n\tconsole.log(this.name)\n}\n\nlet personObj = {\n\tname:\"Tony\",\n\tprint:getName1\n}\n\npersonObj.print();\npersonObj.getName2();\n```\n\n1. undefined undefined\n2. Tony undefined\n3. undefined Tony\n4. Tony Tony",
        "example": "```javascript\n// Arrow functions vs regular functions - 'this' binding\nvar globalName = 'Global';\n\nvar obj = {\n    name: 'Object',\n    regularMethod: function() {\n        console.log('Regular:', this.name); // 'Object'\n    },\n    arrowMethod: () => {\n        console.log('Arrow:', this.name); // 'Global' (or undefined)\n    },\n    nestedExample: function() {\n        console.log('Outer:', this.name); // 'Object'\n        \n        var innerRegular = function() {\n            console.log('Inner regular:', this.name); // 'Global' (or undefined)\n        };\n        \n        var innerArrow = () => {\n            console.log('Inner arrow:', this.name); // 'Object'\n        };\n        \n        innerRegular();\n        innerArrow();\n    }\n};\n\nobj.regularMethod(); // Regular: Object\nobj.arrowMethod();   // Arrow: Global\nobj.nestedExample();\n// Outer: Object\n// Inner regular: Global\n// Inner arrow: Object\n\n// Prototype methods\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.regularGreet = function() {\n    console.log('Hello, I am ' + this.name);\n};\n\nPerson.prototype.arrowGreet = () => {\n    console.log('Hello, I am ' + this.name); // 'this' is not the instance\n};\n\nvar person = new Person('Alice');\nperson.regularGreet(); // Hello, I am Alice\nperson.arrowGreet();   // Hello, I am undefined\n```",
        "solution": "**Answer: 2) Tony undefined**\n\n**Explanation:**\n- `personObj.print()` calls `getName1` as a method, so `this` refers to `personObj` and `this.name` is \"Tony\"\n- `personObj.getName2()` calls an arrow function defined on `Object.prototype`. Arrow functions don't have their own `this` - they inherit it from the enclosing scope. Since the arrow function was defined at the global level, `this` refers to the global object where `name` is `undefined`\nRegular functions have dynamic `this` binding, while arrow functions have lexical `this` binding.",
        "category": "Functions",
        "difficulty": "Hard"
    },
    {
        "id": 120,
        "question": "## What would be the output of the following code?\n\n```javascript\nlet a = true;\nlet c = 0;\n\nsetTimeout(() => {\n\ta = false;\n},2000)\n\nwhile(a){\n\tconsole.log('Hello')\n}\n```",
        "example": "```javascript\n// Event loop and blocking code examples\nconsole.log('Start');\n\nsetTimeout(() => {\n    console.log('Timeout callback');\n}, 0);\n\nsetImmediate(() => {\n    console.log('Immediate callback');\n});\n\n// Blocking loop\nvar start = Date.now();\nwhile (Date.now() - start < 1000) {\n    // Block for 1 second\n}\n\nconsole.log('End');\n// Output: Start, End, Immediate callback, Timeout callback\n\n// Non-blocking alternative\nfunction processArray(array, callback) {\n    if (array.length === 0) {\n        callback();\n        return;\n    }\n    \n    console.log('Processing:', array[0]);\n    \n    setTimeout(() => {\n        processArray(array.slice(1), callback);\n    }, 0);\n}\n\nprocessArray([1, 2, 3, 4, 5], () => {\n    console.log('Processing complete');\n});\n\n// Promise-based alternative\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function delayedExecution() {\n    console.log('Before delay');\n    await delay(1000);\n    console.log('After delay');\n}\n```",
        "solution": "**Answer: The above program will print Hello infinitely.**\n\n**Explanation:** JavaScript is single-threaded with an event loop. The `while(a)` loop runs synchronously on the main thread and blocks execution. Although `setTimeout` is set to change `a` to `false` after 2000ms, the timer callback is placed in the event queue and can only execute when the main thread is free. Since the `while` loop never releases control of the main thread (it's an infinite loop), the timer callback never gets a chance to execute, so `a` remains `true` forever.",
        "category": "Asynchronous",
        "difficulty": "Hard"
    }
]