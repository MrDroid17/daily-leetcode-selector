[
    {
        "id": 1,
        "question": "## What's the difference between `undefined` and `not defined` in JavaScript?",
        "example": "```javascript\nvar x; // declaring x\nconsole.log(x); // output: undefined\n\nconsole.log(y); // Output: ReferenceError: y is not defined\n```",
        "solution": "In JavaScript if you try to use a variable that doesn't exist and has not been declared, then JavaScript will throw an error `var name is not defined` and the script will stop executing thereafter. But If you use `typeof undeclared_variable` then it will return `undefined`.\n\nBefore starting further discussion let's understand the difference between declaration and definition.\n\n`var x` is a declaration because we are not defining what value it holds yet, but we are declaring its existence and the need for memory allocation.\n\n```javascript\nvar x; // declaring x\nconsole.log(x); // output: undefined\n```\n\n`var x = 1` is both declaration and definition, here declaration and assignment of value happen inline for variable x—what we are doing is called \"initialisation\". In JavaScript both variable declarations and function declarations go to the top of the scope in which they are declared, then assignment happens—this series of events is called \"hoisting\".\n\nA variable can be declared but not defined. When we try to access it, It will result `undefined`.\n\n```javascript\nvar x; // Declaration\ntypeof x === 'undefined'; // Will return true\n```\n\nA variable can be neither declared nor defined. When we try to reference such variable then the result will be `not defined`.\n\n```javascript\nconsole.log(y);  // Output: ReferenceError: y is not defined\n```",
        "category": "Variables",
        "difficulty": "Easy"
    },
    {
        "id": 2,
        "question": "## For which value of `x` the results of the following statements are not the same?\n\n```javascript\nif( x <= 100 ) {...}\nif( !(x > 100) ) {...}\n```",
        "example": "```javascript\nvar x = NaN;\nconsole.log(x <= 100);    // false\nconsole.log(!(x > 100));  // true\n```",
        "solution": "`NaN <= 100` is `false` and `NaN > 100` is also `false`, so if the value of `x` is `NaN`, the statements are not the same.\n\nThe same holds true for any value of x that being converted to type Number, returns `NaN`, e.g.: `undefined`, `[1,2,5]`, `{a:22}` , etc.\n\nThis is why you need to pay attention when you deal with numeric variables. `NaN` can't be equal, less than or more than any other numeric value, so the only reliable way to check if the value is `NaN`, is to use the `isNaN()` function.",
        "category": "Data Types",
        "difficulty": "Medium"
    },
    {
        "id": 3,
        "question": "## What is the drawback of declaring methods directly in JavaScript objects?",
        "example": "```javascript\nvar Employee = function (name, company, salary) {\n  this.name = name || \"\";\n  this.company = company || \"\";\n  this.salary = salary || 5000;\n  \n  // Method declared directly in constructor\n  this.formatSalary = function () {\n    return \"$ \" + this.salary;\n  };\n};\n\n// Each instance has its own copy of formatSalary\nvar emp1 = new Employee('John', 'Company 1', 1000000);\nvar emp2 = new Employee('Jane', 'Company 2', 1039999);\n```",
        "solution": "One of the drawbacks of declaring methods directly in JavaScript objects is that they are very memory inefficient. When you do that, a new copy of the method is created for each instance of an object.\n\n```javascript\nvar Employee = function (name, company, salary) {\n  this.name = name || \"\";\n  this.company = company || \"\";\n  this.salary = salary || 5000;\n  \n  // Inefficient: Each instance gets its own copy\n  this.formatSalary = function () {\n    return \"$ \" + this.salary;\n  };\n};\n\n// Alternatively we can add the method to Employee's prototype:\nEmployee.prototype.formatSalary2 = function() {\n    return \"$ \" + this.salary;\n}\n\n//creating objects\nvar emp1 = new Employee('Yuri Garagin', 'Company 1', 1000000);\nvar emp2 = new Employee('Dinesh Gupta', 'Company 2', 1039999);\nvar emp3 = new Employee('Erich Fromm', 'Company 3', 1299483);\n```\n\nIn this case each instance variable `emp1`, `emp2`, `emp3` has its own copy of the `formatSalary` method. However the `formatSalary2` will only be added once to `Employee.prototype`.",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 4,
        "question": "## What is \"closure\" in JavaScript? Can you provide an example?",
        "example": "```javascript\nvar globalVar = \"abc\";\n\n(function outerFunction (outerArg) {\n  var outerFuncVar = 'x';\n  \n  (function innerFunction (innerArg) {\n    var innerFuncVar = \"y\";\n    console.log(\n      \"outerArg = \" + outerArg + \"\\n\" +\n      \"innerArg = \" + innerArg + \"\\n\" +\n      \"outerFuncVar = \" + outerFuncVar + \"\\n\" +\n      \"innerFuncVar = \" + innerFuncVar + \"\\n\" +\n      \"globalVar = \" + globalVar);\n  })(5);\n})(7);\n```",
        "solution": "A closure is a function defined inside another function (called parent function) and as such it has access to the variables declared and defined within its parent function's scope.\n\nThe closure has access to the variables in three scopes:\n\n- Variable declared in its own scope\n- Variable declared in its parent function's scope\n- Variable declared in the global namespace\n\n```javascript\nvar globalVar = \"abc\"; //Global variable\n\n// Parent self-invoking function\n(function outerFunction (outerArg) { // start of outerFunction's scope\n\n  var outerFuncVar = 'x';\n  \n  // Closure self-invoking function\n  (function innerFunction (innerArg) { // start of innerFunction's scope\n\n    var innerFuncVar = \"y\";\n    console.log(\n      \"outerArg = \" + outerArg + \"\\n\" +\n      \"innerArg = \" + innerArg + \"\\n\" +\n      \"outerFuncVar = \" + outerFuncVar + \"\\n\" +\n      \"innerFuncVar = \" + innerFuncVar + \"\\n\" +\n      \"globalVar = \" + globalVar);\n\n  // end of innerFunction's scope\n  })(5); // Pass 5 as parameter to our Closure\n\n// end of outerFunction's scope\n})(7); // Pass 7 as parameter to the Parent function\n```\n\n`innerFunction` is a closure which is defined inside `outerFunction` and consequently has access to all the variables which have been declared and defined within `outerFunction`'s scope as well as any variables residing in the program's global scope.\n\nThe output of the code above would be:\n\n```javascript\nouterArg = 7\nouterFuncVar = x\ninnerArg = 5\ninnerFuncVar = y\nglobalVar = abc\n```",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 5,
        "question": "## Write a mul function which will work properly when invoked with following syntax:\n\n```javascript\nconsole.log(mul(2)(3)(4)); // output : 24\nconsole.log(mul(4)(3)(4)); // output : 48\n```",
        "example": "```javascript\nfunction mul (x) {\n  return function (y) {\n    return function (z) {\n      return x * y * z;\n    };\n  };\n}\n\nconsole.log(mul(2)(3)(4)); // 24\nconsole.log(mul(4)(3)(4)); // 48\n```",
        "solution": "```javascript\nfunction mul (x) {\n  return function (y) { // anonymous function\n    return function (z) { // anonymous function\n      return x * y * z;\n    };\n  };\n}\n```\n\nHere the `mul` function accepts the first argument and returns an anonymous function which then takes the second parameter and returns one last anonymous function which finally takes the third and final parameter; the last function then multiplies `x`, `y` and `z`, and returns the result of the operation.\n\nIn Javascript, a function defined inside another function has access to the outer function's scope and can consequently return, interact with or pass on to other functions, the variables belonging to the scopes that incapsulate it.\n\n- A function is an instance of the Object type\n- A function can have properties and has a link to its constructor method\n- A function can be stored as a variable\n- A function can be passed as a parameter to another function\n- A function can be returned by another function",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 6,
        "question": "## How to empty an array in JavaScript?\n\nFor instance:\n\n```javascript\nvar arrayList =  ['a', 'b', 'c', 'd', 'e', 'f'];\n```\n\nHow can we empty the array above?",
        "example": "```javascript\nvar arrayList = ['a', 'b', 'c', 'd', 'e', 'f'];\n\n// Method 1\narrayList = [];\n\n// Method 2\narrayList.length = 0;\n\n// Method 3\narrayList.splice(0, arrayList.length);\n\n// Method 4\nwhile(arrayList.length) {\n  arrayList.pop();\n}\n```",
        "solution": "There are a couple of ways by which we can empty an array, So let's discuss all the possible way by which we can empty an array.\n\n#### Method 1\n\n```javascript\narrayList = [];\n```\n\nThe code above will set the variable `arrayList` to a new empty array. This is recommended if you don't have **references to the original array** `arrayList` anywhere else because It will actually create a new empty array. You should be careful with this way of empty the array, because if you have referenced this array from another variable, then the original reference array will remain unchanged, Only use this way if you have only referenced the array by its original variable `arrayList`.\n\nFor instance:\n\n```javascript\nvar arrayList = ['a', 'b', 'c', 'd', 'e', 'f']; // Created array\nvar anotherArrayList = arrayList;  // Referenced arrayList by another variable\narrayList = []; // Empty the array\nconsole.log(anotherArrayList); // Output ['a', 'b', 'c', 'd', 'e', 'f']\n```\n\n#### Method 2\n\n```javascript\narrayList.length = 0;\n```\n\nThe code above will clear the existing array by setting its length to 0. This way of emptying an array will also update all the reference variables that point to the original array.\n\nFor instance:\n\n```javascript\nvar arrayList = ['a', 'b', 'c', 'd', 'e', 'f']; // Created array\nvar anotherArrayList = arrayList;  // Referenced arrayList by another variable\narrayList.length = 0; // Empty the array by setting length to 0\nconsole.log(anotherArrayList); // Output []\n```\n\n#### Method 3\n\n```javascript\narrayList.splice(0, arrayList.length);\n```\n\nAbove implementation will also work perfectly. This way of empty the array will also update all the references of the original array.\n\n#### Method 4\n\n```javascript\nwhile(arrayList.length) {\n  arrayList.pop();\n}\n```\n\nAbove implementation can also empty the array. But not recommended to use often.",
        "category": "Arrays",
        "difficulty": "Easy"
    },
    {
        "id": 7,
        "question": "## How to check if an object is an array or not?",
        "example": "```javascript\nvar arrayList = [1, 2, 3];\n\n// Method 1: toString\nif(Object.prototype.toString.call(arrayList) === '[object Array]') {\n  console.log('Array!');\n}\n\n// Method 2: jQuery\nif($.isArray(arrayList)) {\n  console.log('Array');\n}\n\n// Method 3: Modern way\nArray.isArray(arrayList);\n```",
        "solution": "The best way to find whether an object is instance of a particular class or not using `toString` method from `Object.prototype`\n\n```javascript\nvar arrayList = [1 , 2, 3];\n```\n\nOne of the best use cases of type checking of an object is when we do method overloading in JavaScript. To understand this, let's say we have a method called `greet` which can take a single string and also a list of strings. To make our `greet` method workable in both situation we need to know what kind of parameter is being passed: is it single value or list of values?\n\nComing back to checking the type of an object, As we mentioned that we can use `Object.prototype.toString`\n\n```javascript\nif(Object.prototype.toString.call(arrayList) === '[object Array]') {\n  console.log('Array!');\n}\n```\n\nIf you are using `jQuery` then you can also used jQuery `isArray` method:\n\n```javascript\nif($.isArray(arrayList)) {\n  console.log('Array');\n} else {\n  console.log('Not an array');\n}\n```\n\nFYI jQuery uses `Object.prototype.toString.call` internally to check whether an object is an array or not.\n\nIn modern browser, you can also use:\n\n```javascript\nArray.isArray(arrayList);\n```\n\n`Array.isArray` is supported by Chrome 5, Firefox 4.0, IE 9, Opera 10.5 and Safari 5",
        "category": "Arrays",
        "difficulty": "Easy"
    },
    {
        "id": 8,
        "question": "## What will be the output of the following code?\n\n```javascript\nvar output = (function(x) {\n  delete x;\n  return x;\n})(0);\n\nconsole.log(output);\n```",
        "example": "```javascript\nvar output = (function(x) {\n  delete x;\n  return x;\n})(0);\n\nconsole.log(output); // Output: 0\n```",
        "solution": "The code above will output `0` as output. `delete` operator is used to delete a property from an object. Here `x` is not an object, it's a **local variable**. `delete` operator doesn't affect local variables.",
        "category": "Operators",
        "difficulty": "Medium"
    },
    {
        "id": 9,
        "question": "## What will be the output of the following code?\n\n```javascript\nvar x = 1;\nvar output = (function() {\n  delete x;\n  return x;\n})();\n\nconsole.log(output);\n```",
        "example": "```javascript\nvar x = 1;\nvar output = (function() {\n  delete x;\n  return x;\n})();\n\nconsole.log(output); // Output: 1\n```",
        "solution": "The code above will output `1` as output. `delete` operator is used to delete a property from an object. Here `x` is not an object it's **global variable** of type `number`.",
        "category": "Operators",
        "difficulty": "Medium"
    },
    {
        "id": 10,
        "question": "## What will be the output of the following code?\n\n```javascript\nvar x = { foo : 1};\nvar output = (function() {\n  delete x.foo;\n  return x.foo;\n})();\n\nconsole.log(output);\n```",
        "example": "```javascript\nvar x = { foo : 1};\nvar output = (function() {\n  delete x.foo;\n  return x.foo;\n})();\n\nconsole.log(output); // Output: undefined\n```",
        "solution": "The code above will output `undefined` as output. `delete` operator is used to delete a property from an object. Here `x` is an object which has foo as a property and from a self-invoking function, we are deleting the `foo` property of object `x` and after deletion, we are trying to reference deleted property `foo` which result `undefined`.",
        "category": "Operators",
        "difficulty": "Medium"
    },
    {
        "id": 11,
        "question": "## What will be the output of the following code?\n\n```javascript\nvar Employee = {\n  company: 'xyz'\n}\nvar emp1 = Object.create(Employee);\ndelete emp1.company\nconsole.log(emp1.company);\n```",
        "example": "```javascript\nvar Employee = {\n  company: 'xyz'\n}\nvar emp1 = Object.create(Employee);\ndelete emp1.company\nconsole.log(emp1.company); // Output: xyz\n```",
        "solution": "The code above will output `xyz` as output. Here `emp1` object got company as **prototype** property. delete operator doesn't delete prototype property.\n\n`emp1` object doesn't have **company** as its own property. you can test it `console.log(emp1.hasOwnProperty('company')); //output : false` However, we can delete company property directly from `Employee` object using `delete Employee.company` or we can also delete from `emp1` object using `__proto__` property `delete emp1.__proto__.company`.",
        "category": "Objects",
        "difficulty": "Hard"
    },
    {
        "id": 12,
        "question": "## What is `undefined x 1` in JavaScript?\n\n```javascript\nvar trees = [\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\"];\ndelete trees[3];\n```",
        "example": "```javascript\nvar trees = [\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\"];\ndelete trees[3];\nconsole.log(trees); \n// Chrome: [\"redwood\", \"bay\", \"cedar\", undefined × 1, \"maple\"]\n// Firefox: [\"redwood\", \"bay\", \"cedar\", undefined, \"maple\"]\n```",
        "solution": "- When you run the code above and do `console.log(trees);` in chrome developer console then you will get `[\"redwood\", \"bay\", \"cedar\", undefined × 1, \"maple\"]`.\n- When you run the same code in Firefox browser console then you will get `[\"redwood\", \"bay\", \"cedar\", undefined, \"maple\"]`\n\nClearly we can see that Chrome has its own way of displaying uninitialized index in arrays. However when you check `trees[3] === undefined` in any browser you will get similar output as `true`.\n\n**Note:** Please remember that you need not check for the uninitialized index of the array in `trees[3] === 'undefined × 1'` it will give an error because `'undefined × 1'` this is just way of displaying an uninitialized index of an array in chrome.",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 13,
        "question": "## What will be the output of the following code?\n\n```javascript\nvar trees = [\"xyz\", \"xxxx\", \"test\", \"ryan\", \"apple\"];\ndelete trees[3];\nconsole.log(trees.length);\n```",
        "example": "```javascript\nvar trees = [\"xyz\", \"xxxx\", \"test\", \"ryan\", \"apple\"];\ndelete trees[3];\nconsole.log(trees.length); // Output: 5\n```",
        "solution": "The code above will output `5` as output. When we used `delete` operator for deleting an array element then, the array length is not affected by this. This holds even if you deleted all elements of an array using `delete` operator.\n\nSo when delete operator removes an array element that deleted element is no longer present in the array. In place of value at deleted index `undefined x 1` in **chrome** and `undefined` is placed at the index. If you do `console.log(trees)` output `[\"xyz\", \"xxxx\", \"test\", undefined × 1, \"apple\"]` in Chrome and in Firefox `[\"xyz\", \"xxxx\", \"test\", undefined, \"apple\"]`.",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 14,
        "question": "## What will be the output of the following code?\n\n```javascript\nvar bar = true;\nconsole.log(bar + 0);   \nconsole.log(bar + \"xyz\");  \nconsole.log(bar + true);  \nconsole.log(bar + false);\n```",
        "example": "```javascript\nvar bar = true;\nconsole.log(bar + 0);     // 1\nconsole.log(bar + \"xyz\"); // \"truexyz\"\nconsole.log(bar + true);  // 2\nconsole.log(bar + false); // 1\n```",
        "solution": "The code above will output `1, \"truexyz\", 2, 1` as output. Here's a general guideline for the plus operator:\n- Number + Number  -> Addition\n- Boolean + Number -> Addition\n- Boolean + Boolean -> Addition\n- Number + String -> Concatenation\n- String + Boolean -> Concatenation\n- String + String -> Concatenation",
        "category": "Operators",
        "difficulty": "Easy"
    },
    {
        "id": 15,
        "question": "## What will be the output of the following code?\n\n```javascript\nvar z = 1, y = z = typeof y;\nconsole.log(y);\n```",
        "example": "```javascript\nvar z = 1, y = z = typeof y;\nconsole.log(y); // Output: \"undefined\"\n```",
        "solution": "The code above will print string `\"undefined\"` as output. According to associativity rule operator with the same precedence are processed based on their associativity property of operator. Here associativity of the assignment operator is `Right to Left` so first `typeof y` will evaluate first which is string `\"undefined\"` and assigned to `z` and then `y` would be assigned the value of z. The overall sequence will look like that:\n\n```javascript\nvar z;\nz = 1;\nvar y;\nz = typeof y;\ny = z;\n```",
        "category": "Operators",
        "difficulty": "Hard"
    },
    {
        "id": 16,
        "question": "## What will be the output of the following code?\n\n```javascript\n// NFE (Named Function Expression)\nvar foo = function bar() { return 12; };\ntypeof bar();\n```",
        "example": "```javascript\nvar foo = function bar() { return 12; };\nconsole.log(typeof bar()); // ReferenceError: bar is not defined\n```",
        "solution": "The output will be `Reference Error`.\n\nThe problem lies in how **named function expressions** work in JavaScript.\n\nWhen you write `var foo = function bar() { ... };`, you are creating a function expression. The name `bar` is only available and accessible **inside the function's own scope**. It is not visible to the outer (global) scope where you are trying to call it. The function itself is assigned to the variable `foo`, which *is* accessible.\n\n-----\n\nTo fix the bug we can try to rewrite the code a little bit:\n\n**Sample 1**\n\n```javascript\nvar bar = function() { return 12; };\ntypeof bar();\n```\n\nor\n\n**Sample 2**\n\n```javascript\nfunction bar() { return 12; };\ntypeof bar();\n```\n\nThe function definition can have only one reference variable as a function name, In **sample 1** `bar` is reference variable which is pointing to `anonymous function` and in **sample 2** we have function statement and `bar` is the function name.\n\n```javascript\nvar foo = function bar() {\n  // foo is visible here\n  // bar is visible here\n  console.log(typeof bar()); // Works here :)\n};\n// foo is visible here\n// bar is undefined here\n```",
        "category": "Functions",
        "difficulty": "Hard"
    },
    {
        "id": 17,
        "question": "## What is the difference between declaring a function in the formats listed below?\n\n```javascript\nvar foo = function() {\n  // Some code\n}\n```\n\n```javascript\nfunction bar () {\n  // Some code\n}\n```",
        "example": "```javascript\n// Function Expression\nfoo(); // Error: foo is not a function\nvar foo = function() {\n  console.log(\"Hi I am inside Foo\");\n};\n\n// Function Declaration\nbar(); // Works fine\nfunction bar() {\n  console.log(\"Hi I am inside Bar\");\n}\n```",
        "solution": "The main difference is that function `foo` is defined at `run-time` and is called a function expression, whereas function `bar` is defined at `parse time` and is called a function statement. To understand it better, let's take a look at the code below:\n\n```javascript\n// Run-Time function declaration\nfoo(); // Call foo function here, It will give an error\nvar foo = function() {\n  console.log(\"Hi I am inside Foo\");\n};\n```\n\n```javascript\n// Parse-Time function declaration\nbar(); // Call bar function here, It will not give an Error\nfunction bar() {\n  console.log(\"Hi I am inside Bar\");\n}\n```",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 18,
        "question": "## What is the output of the following?\n\n```javascript\nbar();\n(function abc(){console.log('something')})();\nfunction bar(){console.log('bar got called')};\n```",
        "example": "```javascript\nbar();\n(function abc(){console.log('something')})();\nfunction bar(){console.log('bar got called')};\n\n// Output:\n// bar got called\n// something\n```",
        "solution": "The output will be:\n```\nbar got called\nsomething\n```\nSince the function is called first and defined during parse time the JS engine will try to find any possible parse time definitions and start the execution loop which will mean function is called first even if the definition is post another function.",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 19,
        "question": "## In which case the function definition is not hoisted in JavaScript?",
        "example": "```javascript\nfoo(); // Here foo is still undefined\nvar foo = function foo() {\n  return 12;\n};\n\n// Behind the scenes:\nvar foo = undefined;\nfoo(); // TypeError: foo is not a function\nfoo = function foo() {\n  return 12;\n};\n```",
        "solution": "Let's take the following **function expression**\n\n```javascript\nvar foo = function foo() {\n  return 12;\n}\n```\n\nIn JavaScript `var`-declared variables and functions are `hoisted`. Let's take function `hoisting` first. Basically, the JavaScript interpreter looks ahead to find all the variable declaration and hoists them to the top of the function where it's declared. For example:\n\n```javascript\nfoo(); // Here foo is still undefined\nvar foo = function foo() {\n  return 12;\n};\n```\n\nThe code above behind the scene look something like this:\n\n```javascript\nvar foo = undefined;\nfoo(); // Here foo is undefined\nfoo = function foo() {\n  // Some code stuff\n}\n```\n\n```javascript\nvar foo = undefined;\nfoo = function foo() {\n  // Some code stuff\n}\nfoo(); // Now foo is defined here\n```",
        "category": "Hoisting",
        "difficulty": "Hard"
    },
    {
        "id": 20,
        "question": "## What will be the output of the following code?\n\n```javascript\nvar salary = \"1000$\";\n\n(function () {\n  console.log(\"Original salary was \" + salary);\n  var salary = \"5000$\";\n  console.log(\"My New Salary \" + salary);\n})();\n```",
        "example": "```javascript\nvar salary = \"1000$\";\n\n(function () {\n  console.log(\"Original salary was \" + salary); // undefined\n  var salary = \"5000$\";\n  console.log(\"My New Salary \" + salary);        // \"5000$\"\n})();\n```",
        "solution": "The code above will output: `undefined, 5000$` because of hoisting. In the code presented above, you might be expecting `salary` to retain it values from outer scope until the point that `salary` was re-declared in the inner scope. But due to `hoisting` salary value was `undefined` instead. To understand it better have a look of the following code, here `salary` variable is hoisted and declared at the top in function scope. When we print its value using `console.log` the result is `undefined`. Afterwards the variable is redeclared and the new value `\"5000$\"` is assigned to it.\n\n```javascript\nvar salary = \"1000$\";\n\n(function () {\n  var salary = undefined;\n  console.log(\"Original salary was \" + salary);\n  salary = \"5000$\";\n  console.log(\"My New Salary \" + salary);\n})();\n```",
        "category": "Hoisting",
        "difficulty": "Hard"
    },
    {
        "id": 21,
        "question": "## What's the difference between `typeof` and `instanceof`?",
        "example": "```javascript\n// typeof example\nconst name = \"Sobhit\";\nconst age = 30;\nconst person = { name: \"Sobhit\" };\n\nconsole.log(typeof name);   // \"string\"\nconsole.log(typeof age);    // \"number\"\nconsole.log(typeof person); // \"object\"\n\n// instanceof example\nclass Person {}\nconst sobhit = new Person();\n\nconsole.log(sobhit instanceof Person); // true\nconsole.log(person instanceof Person); // false\nconsole.log([] instanceof Array);      // true\nconsole.log({} instanceof Object);     // true\n```",
        "solution": "**In short:** Use `typeof` for checking primitive types. Use `instanceof` to check an object's specific \"class\" or type (e.g., `myVar instanceof Array`).\n\n```javascript\n// typeof example\nconst name = \"Sobhit\";\nconst age = 30;\nconst person = { name: \"Sobhit\" };\n\nconsole.log(typeof name);   // \"string\"\nconsole.log(typeof age);    // \"number\"\nconsole.log(typeof person); // \"object\"\n\n// instanceof example\nclass Person {}\nconst sobhit = new Person();\n\nconsole.log(sobhit instanceof Person); // true\nconsole.log(person instanceof Person); // false\nconsole.log([] instanceof Array);      // true\nconsole.log({} instanceof Object);     // true\n```",
        "category": "Operators",
        "difficulty": "Medium"
    },
    {
        "id": 22,
        "question": "## Calculate the length of the associative array\n\n```javascript\nvar counterArray = {\n  A : 3,\n  B : 4\n};\ncounterArray[\"C\"] = 1;\n```",
        "example": "```javascript\nvar counterArray = {\n  A : 3,\n  B : 4\n};\ncounterArray[\"C\"] = 1;\n\n// Method 1\nObject.keys(counterArray).length; // Output 3\n\n// Method 2\nfunction getLength(object) {\n  var count = 0;\n  for(var key in object) {\n    if(object.hasOwnProperty(key)) {\n      count++;\n    }\n  }\n  return count;\n}\n```",
        "solution": "First of all, in the case of JavaScript an associative array is the same as an object. Secondly, even though there is no built-in function or property available to calculate the length/size an object, we can write such function ourselves.\n\n#### Method 1\n\n`Object` has `keys` method which can be used to calculate the length of object.\n\n```javascript\nObject.keys(counterArray).length; // Output 3\n```\n\n#### Method 2\n\nWe can also calculate the length of object by iterating through the object and by doing a count of own property of object. This way we will ignoge the properties that came from the object's prototype chain:\n\n```javascript\nfunction getLength(object) {\n  var count = 0;\n  for(var key in object) {\n    if(object.hasOwnProperty(key)) {\n      count++;\n    }\n  }\n  return count;\n}\n```\n\n#### Method 3\n\nAll modern browsers (including IE9+) support the [`getOwnPropertyNames`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames) method, so we can calculate the length using the following code:\n\n```javascript\nObject.getOwnPropertyNames(counterArray).length; // Output 3\n```\n\n#### Method 4\n\n[Underscore](https://underscorejs.org/#size) and [lodash](https://lodash.com/docs/4.17.10#size) libraries have the method `size` dedicated to calculate the object length. We don't recommend to include one of these libraries just to use the `size` method, but if it's already used in your project - why not?\n\n```javascript\n_.size({one: 1, two: 2, three: 3});\n=> 3\n```",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 23,
        "question": "## Difference between `Function`, `Method` and `Constructor` calls in JavaScript.",
        "example": "```javascript\n// Function call\nfunction helloWorld(name) {\n  return \"hello world, \" + name;\n}\nhelloWorld(\"JS Geeks\"); // \"hello world JS Geeks\"\n\n// Method call\nvar obj = {\n  helloWorld : function() {\n    return \"hello world, \" + this.name;\n  },\n  name: 'John Carter'\n}\nobj.helloWorld(); // \"hello world John Carter\"\n\n// Constructor call\nfunction Employee(name, age) {\n  this.name = name;\n  this.age = age;\n}\nvar emp1 = new Employee('John Doe', 28);\n```",
        "solution": "If your are familiar with Object-oriented programming, More likely familiar to thinking of functions, methods, and class constructors as three separate things. But In JavaScript, these are just three different usage patterns of one single construct.\n\nfunctions : The simplest usages of function call:\n\n```javascript\nfunction helloWorld(name) {\n  return \"hello world, \" + name;\n}\n\nhelloWorld(\"JS Geeks\"); // \"hello world JS Geeks\"\n```\n\nMethods in JavaScript are nothing more than object properties that are functions.\n\n```javascript\nvar obj = {\n  helloWorld : function() {\n    return \"hello world, \" + this.name;\n  },\n  name: 'John Carter'\n}\nobj.helloWorld(); // // \"hello world John Carter\"\n```\n\nNotice how `helloWorld` refer to `this` properties of obj. Here it's clear or you might have already understood that `this` gets bound to `obj`. But the interesting point that we can copy a reference to the same function `helloWorld` in another object and get a difference answer. Let see:\n\n```javascript\nvar obj2 = {\n  helloWorld : obj.helloWorld,\n  name: 'John Doe'\n}\nobj2.helloWorld(); // \"hello world John Doe\"\n```\n\nYou might be wonder what exactly happens in a method call here. Here we call the expression itself determine the binding of this `this`, The expression `obj2.helloWorld()` looks up the `helloWorld` property of obj and calls it with receiver object `obj2`.\n\nThe third use of functions is as constructors. Like function and method, `constructors` are defined with function.\n\n```javascript\nfunction Employee(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nvar emp1 = new Employee('John Doe', 28);\nemp1.name; // \"John Doe\"\nemp1.age; // 28\n```\n\nUnlike function calls and method calls, a constructor call `new Employee('John Doe', 28)` creates a brand new object and passes it as the value of `this`, and implicitly returns the new object as its result.\n\nThe primary role of the constructor function is to initialize the object.",
        "category": "Functions",
        "difficulty": "Hard"
    },
    {
        "id": 24,
        "question": "## What would be the output of the following code?\n\n```javascript\nfunction User(name) {\n  this.name = name || \"JsGeeks\";\n}\n\nvar person = new User(\"xyz\")[\"location\"] = \"USA\";\nconsole.log(person);\n```",
        "example": "```javascript\nfunction User(name) {\n  this.name = name || \"JsGeeks\";\n}\n\nvar person = new User(\"xyz\")[\"location\"] = \"USA\";\nconsole.log(person); // Output: \"USA\"\n```",
        "solution": "The output of above code would be `\"USA\"`. Here `new User(\"xyz\")` creates a brand new object and created property `location` on that and `USA` has been assigned to object property location and that has been referenced by the person.\n\nLet say `new User(\"xyz\")` created a object called `foo`. The value `\"USA\"` will be assigned to `foo[\"location\"]`, but according to [ECMAScript Specification](http://www.ecma-international.org/ecma-262/6.0/#sec-assignment-operators-runtime-semantics-evaluation) , pt 12.14.4 the assignment will itself return the rightmost value: in our case it's `\"USA\"`.\nThen it will be assigned to person.\n\n```javascript\nfunction User(name) {\n  this.name = name || \"JsGeeks\";\n}\n\nvar person;\nvar foo = new User(\"xyz\");\nfoo[\"location\"] = \"USA\";\n// the console will show you that the result of this is \"USA\"\n```",
        "category": "Objects",
        "difficulty": "Hard"
    },
    {
        "id": 25,
        "question": "## What are Service Workers and when can you use them?",
        "example": "```javascript\n// Register Service Worker\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('/sw.js')\n      .then(registration => {\n        console.log('SW registered: ', registration);\n      })\n      .catch(registrationError => {\n        console.log('SW registration failed: ', registrationError);\n      });\n  });\n}\n\n// sw.js - Service Worker Script\nconst CACHE_NAME = 'my-site-cache-v1';\nconst urlsToCache = [\n  '/',\n  '/styles/main.css',\n  '/script/app.js'\n];\n\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => {\n        return cache.addAll(urlsToCache);\n      })\n  );\n});\n```",
        "solution": "A **Service Worker** is a script that your browser runs in the background, separate from a web page. It acts as a network proxy, intercepting network requests, managing caching, and enabling features that don't need a visible web page, like push notifications.\n\nYou can use them for:\n\n* **Offline functionality**: Cache resources so your app works without internet\n* **Push notifications**: Send notifications even when your app isn't open\n* **Background Sync**: Deferring actions like sending form data until the user has a stable connection.\n\n### Example\n\nHere's how you'd register a service worker and cache some files for offline use.\n\n**1. Register the Service Worker (in your main JavaScript file, e.g., `app.js`)**\n\n```javascript\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('/sw.js')\n      .then(registration => {\n        console.log('SW registered: ', registration);\n      })\n      .catch(registrationError => {\n        console.log('SW registration failed: ', registrationError);\n      });\n  });\n}\n```\n\n**2. The Service Worker Script (in `sw.js` in your root directory)**\n\n```javascript\nconst CACHE_NAME = 'my-site-cache-v1';\nconst urlsToCache = [\n  '/',\n  '/styles/main.css',\n  '/script/app.js'\n];\n\n// Install event: cache the essential files\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => {\n        return cache.addAll(urlsToCache);\n      })\n  );\n});\n\n// Fetch event: serve cached content when offline\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request)\n      .then(response => {\n        // Return cached version or fetch from network\n        return response || fetch(event.request);\n      }\n    )\n  );\n});\n```",
        "category": "Web APIs",
        "difficulty": "Hard"
    },
    {
        "id": 26,
        "question": "## What is the difference between a method and a function in JavaScript?",
        "example": "```javascript\n// Function\nfunction myFunc() {\n  console.log(\"I'm a function\");\n}\nmyFunc();\n\n// Method\nvar obj1 = {\n  attribute: \"xyz\",\n  myMethod: function () {\n    console.log(this.attribute);\n  }\n};\nobj1.myMethod();\n\n// Arrow function\nconst myArrowFunc = arg => {\n    console.log(\"hello\", arg);\n}\n```",
        "solution": "In JS, that difference is quite subtle. A function is a piece of code that is called by name and function itself not associated with any object and not defined inside any object. It can be passed data to operate on (i.e. parameter) and can optionally return data (the return value).\n\n```javascript\n// Function statement\nfunction myFunc() {\n  // Do some stuff;\n}\n\n// Calling the function\nmyFunc();\n```\n\nHere myFunc() function call is not associated with object hence not invoked through any object.\n\nA function can take a form of immediately invoked function expression (IIFE):\n\n```javascript\n// Anonymous Self-invoking Function\n(function() {\n  // Do some stuff;\n})();\n```\n\nFinally there are also arrow functions:\n\n```javascript\nconst myFunc = arg => {\n    console.log(\"hello\", arg)\n}\n```\n\nA method is a piece of code that is called by its name and that is associated with the object. Methods are functions. When you call a method like this `obj1.myMethod()`, the reference to `obj1` gets assigned (bound) to `this` variable. In other words, the value of `this` will be `obj1` inside `myMethod`.\n\nHere are some examples of methods:\n\n##### Example 1\n```javascript\nvar obj1 = {\n  attribute: \"xyz\",\n  myMethod: function () {\n    console.log(this.attribute);\n  }\n};\n\n// Call the method\nobj1.myMethod();\n```\n\nHere `obj1` is an object and `myMethod` is a method which is associated with `obj1`.\n\n##### Example 2\nIn ES6 we have classes. There the methods will look like this:\n\n```javascript\nclass MyAwesomeClass {\n  myMethod() {\n    console.log(\"hi there\");\n  }\n}\n\nconst obj1 = new MyAwesomeClass();\nobj1.myMethod();\n```\n\nUnderstand: the method is not some kind of special type of a function, and it's not about how you declare a function. It's the way we **call** a function. Look at that:\n\n```javascript\nvar obj1 = {\n  prop1: \"buddy\"\n};\nvar myFunc = function () {\n  console.log(\"Hi there\", this);\n};\n// let's call myFunc as a function:\nmyFunc(); // will output \"Hi there undefined\" or \"Hi there Window\"\n\nobj1.myMethod = myFunc;\n//now we're calling myFunc as a method of obj1, so this will point to obj1\nobj1.myMethod(); // will print \"Hi there\" following with obj1.\n```",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 27,
        "question": "## What is IIFE (Immediately Invoked Function Expression) and how it can be useful?",
        "example": "```javascript\n// Basic IIFE\n(function() {\n  console.log(\"Hi, I'm IIFE!\");\n})();\n// outputs \"Hi, I'm IIFE!\"\n\n// Named IIFE\n(function myIIFE() {\n  console.log(\"Named IIFE\");\n})();\n\n// IIFE with parameters\n(function(param1) {\n  console.log(\"Hello \" + param1);\n})(\"World\");\n\n// IIFE returning value\nvar result = (function() {\n  return \"I'm returned from IIFE\";\n})();\nconsole.log(result);\n```",
        "solution": "#### Definition\nIIFE a function that runs as soon as it's defined. Usually it's anonymous (doesn't have a function name), but it also can be named. Here's an example of IIFE:\n\n```javascript\n(function() {\n  console.log(\"Hi, I'm IIFE!\");\n})();\n// outputs \"Hi, I'm IIFE!\"\n```\n#### Explanation\n\nSo, here's how it works. Remember the difference between function statements (`function a () {}`) and function expressions (`var a = function() {}`)? So, IIFE is a function expression. To make it an expression we surround our function declaration into the parens. We do it to explicitly tell the parser that it's an expression, not a statement (JS doesn't allow statements in parens).\n\nAfter the function you can see the two `()` braces, this is how we run the function we just declared.\n\nThat's it. The rest is details.\n- The function inside IIFE doesn't have to be anonymous. This one will work perfectly fine and will help to detect your function in a stacktrace during debugging:\n  ```javascript\n  (function myIIFE() {\n    console.log(\"Named IIFE\");\n  })();\n  ```\n- It can take some parameters:\n  ```javascript\n  (function(param1) {\n    console.log(\"Hello \" + param1);\n  })(\"World\");\n  ```\n  Here there value `\"World\"` is passed to the `param1` of the function.\n- It can return a value:\n  ```javascript\n  var result = (function() {\n    return \"I'm returned from IIFE\";\n  })();\n  console.log(result); // \"I'm returned from IIFE\"\n  ```\n- You don't have to surround the function declaration into parens, although it's the most common way to define IIFE. Instead you can use any of the following forms:\n  - `~function(){console.log(\"hi I'm IIFE\")}()`\n  - `!function(){console.log(\"hi I'm IIFE\")}()`\n  - `+function(){console.log(\"hi I'm IIFE\")}()`\n  - `-function(){console.log(\"hi I'm IIFE\")}()`\n  - `(function(){console.log(\"hi I'm IIFE\")}());`\n  - `var i = function(){console.log(\"hi I'm IIFE\")}();`\n  - `true && function(){ console.log(\"hi I'm IIFE\") }();`\n  - `0, function(){ console.log(\"hi I'm IIFE\") }();`\n  - `new function(){ console.log(\"hi I'm IIFE\") }`\n  - `new function(){ console.log(\"hi I'm IIFE\") }()`\n\n  Please don't use all these forms to impress colleagues, but be prepared that you can encounter them in someone's code.\n\n#### Applications and usefulness\n\nVariables and functions that you declare inside an IIFE are not visible to the outside world, so you can:\n - Use the IIFE for isolating parts of the code to hide details of implementation.\n - Specify the input interface of your code by passing commonly used global objects (window, document, jQuery, etc.) IIFE's parameters, and then reference these global objects within the IIFE via a local scope.\n - Use it in closures, when you use closures in loops.\n - IIFE is the basis of in the module pattern in ES5\ncode, it helps to prevent polluting the global scope and provide the module interface to the outside.",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 28,
        "question": "## Describe Singleton Pattern In JavaScript",
        "example": "```javascript\nclass DatabaseConnection {\n  constructor() {\n    if (DatabaseConnection.instance) {\n      return DatabaseConnection.instance;\n    }\n    \n    this.uri = 'mongodb://user:pass@host:485';\n    DatabaseConnection.instance = this;\n    \n    return this;\n  }\n  \n  static getInstance() {\n    if (!DatabaseConnection.instance) {\n      DatabaseConnection.instance = new DatabaseConnection();\n    }\n    return DatabaseConnection.instance;\n  }\n  \n  connect() {\n    console.log(`Connecting with URI: ${this.uri}`);\n  }\n}\n\n// Usage\nconst conn1 = DatabaseConnection.getInstance();\nconst conn2 = DatabaseConnection.getInstance();\n\nconsole.log(conn1 === conn2); // true\n```",
        "solution": "The **Singleton Pattern** ensures that a class can only ever have **one instance**. It provides a global access point to that single instance. This is useful for managing a shared resource, like a configuration manager or a database connection pool, where you want to avoid creating multiple instances.\n\n### Example\n\nThis example creates a `DatabaseConnection` singleton. No matter how many times you ask for the connection, you'll always get the same object.\n\n```javascript\nclass DatabaseConnection {\n  constructor() {\n    if (DatabaseConnection.instance) {\n      return DatabaseConnection.instance;\n    }\n    \n    this.uri = 'mongodb://user:pass@host:485';\n    DatabaseConnection.instance = this;\n    \n    return this;\n  }\n  \n  static getInstance() {\n    if (!DatabaseConnection.instance) {\n      DatabaseConnection.instance = new DatabaseConnection();\n    }\n    return DatabaseConnection.instance;\n  }\n  \n  connect() {\n    console.log(`Connecting with URI: ${this.uri}`);\n  }\n}\n\n// Usage\nconst conn1 = DatabaseConnection.getInstance();\nconst conn2 = DatabaseConnection.getInstance();\n\nconn1.connect(); // Connecting with URI: mongodb://user:pass@host:485\nconn2.connect(); // Connecting with URI: mongodb://user:pass@host:485\n\nconsole.log(conn1 === conn2); // true -> Proves it's the same instance\n```",
        "category": "Design Patterns",
        "difficulty": "Hard"
    },
    {
        "id": 29,
        "question": "## What are the ways of creating objects in JavaScript?",
        "example": "```javascript\n// Method 1: Function based (Constructor)\nfunction Employee(name, lastName, age, salary) {\n  this.name = name;\n  this.lastName = lastName;\n  this.age = age;\n  this.salary = salary;\n}\nvar employee1 = new Employee('John', 'Moto', 26, '5000$');\n\n// Method 2: Object Literal\nvar employee = {\n  name : 'Nishant',\n  salary : '5000$',\n  getName : function(){\n    return this.name;\n  }\n}\n\n// Method 3: Object constructor\nvar employee = new Object();\nemployee.name = 'Nishant';\nemployee.getName = function(){\n  return this.name;\n}\n\n// Method 4: Object.create\nvar employee = Object.create(null);\nemployee.name = 'Nishant';\n```",
        "solution": "#### Method 1: Function based\n\nThis method is useful if we want to create several similar objects. In the code sample below, we wrote the function `Employee` and used it as a constructor by calling it with the `new` operator.\n\n```javascript\nfunction Employee(name, lastName, age, salary){\n  this.name = name;\n  this.lastName = lastName;\n  this.age = age;\n  this.salary = salary;\n}\n\nvar employee1 = new Employee('John', 'Moto', 26, '5000$');\nvar employee2 = new Employee('Paul', 'Newman', 26, '5000$');\nvar employee3 = new Employee('Andre', 'Salt', 26, '4000$');\n```\n\n#### Method 2: Object Literal\n\nObject Literal is best way to create an object and this is used frequently. Below is code sample for create employee object which contains property as well as method.\n\n```javascript\nvar employee = {\n\tname : 'Nishant',\n\tsalary : '5000$',\n\tgetName : function(){\n\t\treturn this.name;\n\t}\n}\n```\nThe code sample below is Nested Object Literal, Here address is an object inside employee object.\n\n```javascript\nvar employee = {\n\tname : 'Nishant',\n\tsalary : '5000$',\n\tgetName : function(){\n\t\treturn this.name;\n\t},\n\taddress : {\n\t\tcity : 'Delhi',\n\t\tlocality : 'ROHINI',\n\t\tregion : 'Delhi'\n\t}\n}\n```\n#### Method 3: From `Object` using `new` keyword\n\nIn the code below, a sample object has been created using `Object`'s constructor function.\n\n```javascript\nvar employee = new Object(); // Created employee object using new keywords and Object()\nemployee.name = 'Nishant';\nemployee.getName = function(){\n\treturn this.name;\n}\n```\n\n#### Method 4:** Using `Object.create`\n\n`Object.create(obj)` will create a new object and set the `obj` as its prototype. It's a modern way to create objects that inherit properties from other objects. `Object.create` function doesn't run the constructor. You can use `Object.create(null)` when you don't want your object to inherit the properties of `Object`.",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 30,
        "question": "## Write a function called deepClone which takes an object and creates a object copy of it.\n\n```javascript\nvar newObject = deepClone(obj);\n```",
        "example": "```javascript\nfunction deepClone(object){\n\tvar newObject = {};\n\tfor(var key in object) {\n\t\tif(typeof object[key] === \"object\"  && object[key] !== null ) {\n\t\t\tnewObject[key] = deepClone(object[key]);\n\t\t} else {\n\t\t\tnewObject[key] = object[key];\n\t\t}\n\t}\n\treturn newObject;\n}\n\nvar personalDetail = {\n\tname : 'Nishant',\n\taddress : {\n\t\tlocation: 'xyz',\n\t\tzip : '123456',\n\t\ttelephoneNumber : {\n\t\t\thome: '08912345678',\n\t\t\toffice: '08976543210'\n\t\t}\n\t}\n}\n\nvar clonedDetail = deepClone(personalDetail);\n```",
        "solution": "```javascript\nfunction deepClone(object){\n\tvar newObject = {};\n\tfor(var key in object) {\n\t\tif(typeof object[key] === \"object\"  && object[key] !== null ) {\n\t\t\tnewObject[key] = deepClone(object[key]);\n\t\t} else {\n\t\t\tnewObject[key] = object[key];\n\t\t}\n\t}\n\treturn newObject;\n}\n```\n\n**Explanation:** We have been asked to do deep copy of object so What's basically it's mean ??. Let's understand in this way you have been given an object `personalDetail` this object contains some property which again a type of object here as you can see `address` is an object and `phoneNumber` in side an `address` is also an object. In simple term `personalDetail` is nested object(object inside object). So Here deep copy means we have to copy all the property of `personalDetail` object including nested object.\n\n```javascript\nvar personalDetail = {\n\tname : 'Nishant',\n\taddress : {\n\t\tlocation: 'xyz',\n\t\tzip : '123456',\n\t\ttelephoneNumber : {\n\t\t\thome: '08912345678',\n\t\t\toffice: '08976543210'\n\t\t}\n\t}\n}\n```\nSo when we do deep clone then we should copy every property (including the nested object).",
        "category": "Objects",
        "difficulty": "Hard"
    },
    {
        "id": 31,
        "question": "## Best way to detect `undefined` object property in JavaScript.",
        "example": "```javascript\nvar person = {\n\tname: 'Nishant',\n\tage : 24\n}\n\n// Check for undefined property\nif(typeof person.salary === 'undefined'){\n\tconsole.log(\"salary is undefined here because we haven't declared\");\n}\n```",
        "solution": "> Suppose we have given an object `person`\n\n```javascript\nvar person = {\n\tname: 'Nishant',\n\tage : 24\n}\n```\nHere the `person` object has a `name` and `age` property. Now we are trying to access the **salary** property which we haven't declared on the person object so while accessing it will return undefined. So how we will ensure whether property is undefined or not before performing some operation over it?\n\n**Explanation:**\n\nWe can use `typeof` operator to check undefined\n\n```javascript\nif(typeof someProperty === 'undefined'){\n\tconsole.log('something is undefined here');\n}\n```\nNow we are trying to access salary property of person object.\n\n```javascript\nif(typeof person.salary === 'undefined'){\n\tconsole.log(\"salary is undefined here because we haven't declared\");\n}\n```",
        "category": "Objects",
        "difficulty": "Easy"
    },
    {
        "id": 32,
        "question": "## Write a function called `Clone` which takes an object and creates a object copy of it but not copy deep property of object.\n\n```javascript\nvar objectLit = {foo : 'Bar'};\n```",
        "example": "```javascript\nfunction Clone(object){\n  var newObject = {};\n  for(var key in object) {\n    newObject[key] = object[key];\n  }\n  return newObject;\n}\n\nvar objectLit = {foo : 'Bar'};\nvar clonedObject = Clone(objectLit);\nconsole.log(clonedObject); // {foo : 'Bar'}\n```",
        "solution": "```javascript\nfunction Clone(object){\n  var newObject = {};\n  for(var key in object){\n  \tnewObject[key] = object[key];\n  }\n  return newObject;\n}\n```",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 33,
        "question": "## What are promises and how they are useful?",
        "example": "```javascript\n// Promise Example: Simulating a Data Fetch\nfunction fetchData() {\n  return new Promise((resolve, reject) => {\n    // Simulate an async operation with setTimeout\n    setTimeout(() => {\n      const success = Math.random() > 0.5; // Random success/failure\n      \n      if (success) {\n        resolve(\"Data fetched successfully!\");\n      } else {\n        reject(new Error(\"Failed to fetch data\"));\n      }\n    }, 2000);\n  });\n}\n\n// Using the Promise\nconsole.log(\"About to fetch data...\");\n\nfetchData()\n  .then(data => {\n    console.log(\"Success:\", data);\n  })\n  .catch(error => {\n    console.error(\"Error:\", error.message);\n  });\n```",
        "solution": "A **Promise** is a JavaScript object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. It provides a cleaner, more robust way to handle asynchronous tasks than traditional callbacks, helping to avoid \"callback hell.\"\n\nA Promise can be in one of three states:\n\n1.  **Pending**: The initial state; not yet fulfilled or rejected.\n2.  **Fulfilled**: The operation completed successfully, and the promise has a resulting value.\n3.  **Rejected**: The operation failed, and the promise has a reason for the failure.\n\n### Static Methods\n\nJavaScript's `Promise` object has several static methods to help manage multiple promises:\n\n  * **`Promise.resolve(value)`**: Returns a new `Promise` object that is resolved with the given value.\n  * **`Promise.all(iterable)`**: Returns a single Promise that fulfills when all promises in the iterable fulfill.\n  * **`Promise.race(iterable)`**: Returns a promise that fulfills or rejects as soon as one of the promises in the iterable fulfills or rejects.\n  * **`Promise.allSettled(iterable)`**: Returns a promise that resolves after all promises have either resolved or rejected.\n  * **`Promise.reject(reason)`**: Returns a new `Promise` object that is rejected with the given reason.\n\n\nThis example simulates fetching data from a server. The promise will randomly either **resolve** (succeed) or **reject** (fail) after a 2-second delay.\n\n### Promise Example: Simulating a Data Fetch\n\n```javascript\n/**\n * This function returns a new Promise.\n * The Promise simulates fetching data from a server.\n */\nfunction fetchData() {\n  // 1. Create and return the new Promise\n  return new Promise((resolve, reject) => {\n    // 2. Simulate an async operation with setTimeout\n    setTimeout(() => {\n      const success = Math.random() > 0.5; // Random success/failure\n      \n      if (success) {\n        // 3a. If successful, call resolve() with the data\n        resolve(\"Data fetched successfully!\");\n      } else {\n        // 3b. If failed, call reject() with an error\n        reject(new Error(\"Failed to fetch data\"));\n      }\n    }, 2000); // Wait 2 seconds\n  });\n}\n\n// --- Using the Promise ---\n\nconsole.log(\"About to fetch data...\");\n\nfetchData()\n  .then(data => {\n    // This runs if the promise resolves\n    console.log(\"Success:\", data);\n  })\n  .catch(error => {\n    // This runs if the promise rejects\n    console.error(\"Error:\", error.message);\n  });\n```\n\n### How to Run It\n\n1.  Copy and paste this code into your browser's developer console or a Node.js file.\n2.  Run it multiple times to see both the success (`.then`) and failure (`.catch`) outcomes.\n\n\nBe sure that you can implement the promise, read [one of the articles on a topic](https://opensourceconnections.com/blog/2014/02/16/a-simple-promise-implementation-in-about-20-lines-of-javascript/), and learn the source code of the [simplest promise implementation](https://gist.github.com/softwaredoug/9044640).",
        "category": "Asynchronous",
        "difficulty": "Medium"
    },
    {
        "id": 34,
        "question": "## How to check whether a key exist in a JavaScript object or not.",
        "example": "```javascript\nvar person = {\n\tname: 'Nishant',\n\tage: 24\n}\n\n// Method 1: Using 'in' operator\nconsole.log('name' in person); // true\nconsole.log('salary' in person); // false\nconsole.log('toString' in person); // true (inherited)\n\n// Method 2: Using hasOwnProperty\nconsole.log(person.hasOwnProperty('toString')); // false\nconsole.log(person.hasOwnProperty('name')); // true\nconsole.log(person.hasOwnProperty('salary')); // false\n```",
        "solution": "Let say we have `person` object with property **name** and **age**\n\n```javascript\nvar person = {\n\tname: 'Nishant',\n\tage: 24\n}\n```\nNow we want to check whether `name` property exist in `person` object or not ?\n\nIn JavaScript object can have own property, in above example name and age is own property of person object. Object also have some of inherited property of base object like toString is inherited property of person object.\n\nSo how we will check whether property is own property or inherited property.\n\nMethod 1: We can use `in` operator on objet to check own property or inherited property.\n\n```javascript\nconsole.log('name' in person); // checking own property print true\nconsole.log('salary' in person); // checking undefined property print false\n```\n`in` operator also look into inherited property if it doesn't find property defined as own property. For instance If I check existence of toString property as we know that we haven't declared this property on person object so `in` operator look into there base property.\n\nHere\n\n```javascript\nconsole.log('toString' in person); // Will print true\n```\nIf we want to test property of object instance not inherited properties then we will use `hasOwnProperty` method of object instance.\n\n```javascript\nconsole.log(person.hasOwnProperty('toString')); // print false\nconsole.log(person.hasOwnProperty('name')); // print true\nconsole.log(person.hasOwnProperty('salary')); // print false\n```",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 35,
        "question": "## What is NaN, what is its datatype, why do we need it, and when can it break the page?",
        "example": "```javascript\nMath.sqrt(-5);           // NaN\nMath.log(-1);            // NaN\nparseFloat(\"foo\");       // NaN\n\nconsole.log(typeof NaN); // \"number\"\n\n// NaN comparisons\nNaN !== NaN;  // true\nNaN < 2;      // false\nNaN > 2;      // false\nNaN === 2;    // false\n\n// Checking for NaN\nisNaN(NaN);               // true\nisNaN(\"hello\");           // true\nNumber.isNaN(NaN);        // true\nNumber.isNaN(\"hello\");    // false\n```",
        "solution": "`NaN` stands for \"not a number.\" and it can break your table of numbers when it has an arithmetic operation that is not allowed. Here are some examples of how you can get `NaN`:\n\n```javascript\nMath.sqrt(-5);\nMath.log(-1);\nparseFloat(\"foo\"); /* this is common: you get JSON from the server, convert some strings from JSON to a number and end up with NaN in your UI. */\n```\n\n**typeof NaN**\n```javascript\nconsole.log(typeof NaN) // number\n```\n\n`NaN` is not equal to any number, it's not less or more than any number, also it's not equal to itself:\n\n```javascript\nNaN !== NaN\nNaN < 2 // false\nNaN > 2 // false\nNaN === 2 // false\n```\n\nTo check if the current value of the variable is NaN, you have to use the `isNaN` function. This is why we can often see NaN in the webpages: it requires special check which a lot of developers forget to do.\n\nFurther reading: [great blogpost on ariya.io](https://ariya.io/2014/05/the-curious-case-of-javascript-nan)",
        "category": "Data Types",
        "difficulty": "Medium"
    },
    {
        "id": 36,
        "question": "## Fix the bug using ES5 only\n\n```javascript\nvar arr = [10, 32, 65, 2];\nfor (var i = 0; i < arr.length; i++) {\n  setTimeout(function() {\n    console.log('The index of this number is: ' + i);\n  }, 3000);\n}\n```",
        "example": "```javascript\n// ES5 Solution 1: IIFE\nvar arr = [10, 32, 65, 2];\nfor (var i = 0; i < arr.length; i++) {\n  setTimeout(function(j) {\n    return function() {\n      console.log('The index of this number is: ' + j);\n    };\n  }(i), 3000);\n}\n\n// ES5 Solution 2: forEach\nvar arr = [10, 32, 65, 2];\narr.forEach(function(ele, i) {\n  setTimeout(function() {\n    console.log('The index of this number is: ' + i);\n  }, 3000);\n})\n\n// ES6 Solution: let\nvar arr = [10, 32, 65, 2];\nfor (let i = 0; i < arr.length; i++) {\n  setTimeout(function() {\n    console.log('The index of this number is: ' + i);\n  }, 3000);\n}\n```",
        "solution": "For ES6, you can just replace `var i` with `let i`.\n\nFor ES5, you need to create a function scope like here:\n\n```javascript\nvar arr = [10, 32, 65, 2];\nfor (var i = 0; i < arr.length; i++) {\n  setTimeout(function(j) {\n    return function() {\n      console.log('The index of this number is: ' + j);\n    };\n  }(i), 3000);\n}\n```\n\nThis can also achieve by forEach (allows you to keep that variable within the forEach's scope)\n\n```javascript\nvar arr = [10, 32, 65, 2];\narr.forEach(function(ele, i) {\n  setTimeout(function() {\n    console.log('The index of this number is: ' + i);\n  }, 3000);\n})\n```",
        "category": "Loops",
        "difficulty": "Hard"
    },
    {
        "id": 37,
        "question": "## How to check if the value of a variable is an array?",
        "example": "```javascript\n// Method 1: Object.prototype.toString\nfunction isArray(value){\n\treturn Object.prototype.toString.call(value) === '[object Array]';\n}\n\n// Method 2: Array.isArray (ES5)\nArray.isArray([1, 2, 3]); // true\nArray.isArray('hello');   // false\n\n// Method 3: instanceof\nfunction isArray(value) {\n\treturn value instanceof Array;\n}\n\n// Method 4: constructor name\nfunction isArray(value) {\n\treturn value.constructor.name === \"Array\";\n}\n\n// Duck typing (not recommended)\nfunction isArray(value){\n\treturn typeof value.sort === 'function';\n}\n```",
        "solution": "We always encounter in such situation where we need to know whether value is type of array or not.\n\nFor instance : the code below perform some operation based value type\n\n```javascript\nfunction(value){\n\tif(\"value is an array\"){\n\t\t// Then perform some operation\n\t}else{\n\t\t// otherwise perform other operation\n\t}\n}\n```\n\nLet's discuss some way to detect an array in JavaScript.\n\n**Method 1:**\n\nJuriy Zaytsev (Also known as kangax) proposed an elegant solution to this.\n\n```javascript\n\tfunction isArray(value){\n\t\treturn Object.prototype.toString.call(value) === '[object Array]';\n\t}\n```\nThis approach is most popular way to detecting a value of type array in JavaScript and recommended to use. This approach relies on the fact that, native toString() method on a given value produce a standard string in all browser.\n\n\n**Method 2:**\n\nDuck typing test for array type detection\n\n```javascript\n // Duck typing arrays\n function isArray(value){\n \treturn typeof value.sort === 'function';\n }\n```\nAs we can see above isArray method will return true if value object have `sort` method of type `function`. Now assume you have created a object with sort method\n\n```javascript\n\tvar bar = {\n\t\tsort: function(){\n\t\t\t// Some code\n\t\t}\n\t}\n```\nNow when you check `isArray(bar)` then it will return true because bar object has sort method, But the fact is bar is not an array.\n\nSo this method is not a best way to detect an array as you can see it's not handle the case when some object has sort method.\n\n**Method 3:**\n\nECMAScript 5 has introduced **Array.isArray()** method to detect an array type value. The sole purpose of this method is accurately detecting whether a value is an array or not.\n\nIn many JavaScript libraries you may see the code below for detecting an value of type array.\n\n```javascript\nfunction(value){\n   // ECMAScript 5 feature\n   if(Array.isArray(value)){\n   \t// Then perform some operation\n   }else{\n   \t// otherwise perform other operation\n   }\n}\n```\n\n**Method 4:**\n\nYou can query the constructor name:\n\n```javascript\nfunction isArray(value) {\n\treturn value.constructor.name === \"Array\";\n}\n\n```\n\n**Method 5:**\n\nYou check  if a given value is an `instanceof Array`:\n\n```javascript\nfunction isArray(value) {\n\treturn value instanceof Array;\n}\n```",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 38,
        "question": "## Best way to detect reference values of any type in JavaScript?",
        "example": "```javascript\n// Using typeof operator\nconsole.log(typeof {});           // object\nconsole.log(typeof []);           // object\nconsole.log(typeof new Array());  // object\nconsole.log(typeof null);         // object\nconsole.log(typeof new RegExp()); // object\nconsole.log(typeof new Date());   // object\n\n// Using instanceof operator\nif(value instanceof Array){\n\tconsole.log(\"value is type of array\");\n}\n\n// Employee constructor function\nfunction Employee(name){\n\tthis.name = name;\n}\n\nvar emp1 = new Employee('John');\nconsole.log(emp1 instanceof Employee); // true\nconsole.log(emp1 instanceof Object);   // true\n```",
        "solution": "In Javascript Object are called as reference type, Any value other then primitive is definitely a reference type. There are several built-in reference type such as **Object**, **Array**, **Function**, **Date**, **null** and **Error**.\n\nDetecting object using `typeof` operator\n\n```javascript\nconsole.log(typeof {});           // object\nconsole.log(typeof []);           // object\nconsole.log(typeof new Array());  // object\nconsole.log(typeof null);         // object \nconsole.log(typeof new RegExp()); // object\nconsole.log(typeof new Date());   // object\n```\nBut the downside of using typeof operator to detect an object is that typeof returns `object` for `null` (However this is fact that null is an object in JavaScript).\n\nThe best way to detect an object of specific reference type using `instanceof` operator.\n\n>Syntax : **value** instanceof **constructor**\n\n```javascript\n//Detecting an array\nif(value instanceof Array){\n\tconsole.log(\"value is type of array\");\n}\n```\n```javascript\n// Employee constructor function\nfunction Employee(name){\n\tthis.name = name; // Public property\n}\n\nvar emp1 = new Employee('John');\n\nconsole.log(emp1 instanceof Employee); // true\n```\n`instanceof` not only check the constructor which is used to create an object but also check it's prototype chain see below example.\n\n```javascript\nconsole.log(emp1 instanceof Object); // true\n```",
        "category": "Data Types",
        "difficulty": "Hard"
    },
    {
        "id": 39,
        "question": "## How does Object.create method work in JavaScript?",
        "example": "```javascript\nvar employee = {\n  name: 'Nishant',\n  displayName: function() {\n    console.log(this.name);\n  }\n};\n\nvar emp1 = Object.create(employee);\nconsole.log(emp1.displayName());  // output \"Nishant\"\n\n// Creating with additional properties\nvar emp2 = Object.create(employee, {\n\tname: {\n\t\tvalue: \"John\"\n\t}\n});\n\nemp2.displayName(); // \"John\"\nemployee.displayName(); // \"Nishant\"\n```",
        "solution": "The ECMAScript 5 **Object.create()** method is the easiest way for one object to inherit from another, without invoking a constructor function.\n\n**For instance:**\n\n```javascript\nvar employee = {\n  name: 'Nishant',\n  displayName: function() {\n    console.log(this.name);\n  }\n};\n\nvar emp1 = Object.create(employee);\nconsole.log(emp1.displayName());  // output \"Nishant\"\n```\n\nIn the example above, we create a new object `emp1` that inherits from `employee`. In other words `emp1`'s prototype is set to `employee`. After this emp1 is able to access the same properties and method on employee until new properties or method with the same name are defined.\n\n**For instance:** Defining `displayName()` method on `emp1` will not automatically override the employee `displayName`.\n\n```javascript\nemp1.displayName = function() {\n\tconsole.log('xyz-Anonymous');\n};\n\nemployee.displayName(); //Nishant\nemp1.displayName();//xyz-Anonymous\n```\n\nIn addition to this **`Object.create(`)** method also allows to specify a second argument which is an object containing additional properties and methods to add to the new object.\n\n**For example**\n\n```javascript\nvar emp1 = Object.create(employee, {\n\tname: {\n\t\tvalue: \"John\"\n\t}\n});\n\nemp1.displayName(); // \"John\"\nemployee.displayName(); // \"Nishant\"\n```\nIn the example above, `emp1` is created with it's own value for name, so calling **displayName()** method will display `\"John\"` instead of `\"Nishant\"`.\n\nObject created in this manner give you full control over newly created object. You are free to add, remove any properties and method you want.",
        "category": "Objects",
        "difficulty": "Hard"
    },
    {
        "id": 40,
        "question": "## How to use constructor functions for inheritance in JavaScript?",
        "example": "```javascript\n// Parent constructor\nfunction Person(name, age, salary) {\n  this.name = name;\n  this.age = age;\n  this.salary = salary;\n  this.incrementSalary = function(byValue) {\n    this.salary = this.salary + byValue;\n  };\n}\n\n// Child constructor\nfunction Employee(company){\n\tthis.company = company;\n}\n\n// Prototypal Inheritance\nEmployee.prototype = new Person(\"Nishant\", 24, 5000);\n\nvar emp1 = new Employee(\"Google\");\nconsole.log(emp1 instanceof Person);   // true\nconsole.log(emp1 instanceof Employee); // true\n\n// Constructor inheritance using call\nfunction Manager(name, department) {\n  Person.call(this, name, 30, 8000);\n  this.department = department;\n}\n\nvar mgr1 = new Manager('Alice', 'Engineering');\nconsole.log(mgr1.name); // \"Alice\"\n```",
        "solution": "Let say we have `Person` class which has name, age, salary properties and **incrementSalary()** method.\n\n```javascript\nfunction Person(name, age, salary) {\n  this.name = name;\n  this.age = age;\n  this.salary = salary;\n  this.incrementSalary = function(byValue) {\n    this.salary = this.salary + byValue;\n  };\n}\n```\n\nNow we wish to create Employee class which contains all the properties of Person class and wanted to add some additional properties into Employee class.\n\n```javascript\nfunction Employee(company){\n\tthis.company = company;\n}\n\n//Prototypal Inheritance \nEmployee.prototype = new Person(\"Nishant\", 24,5000);\n```\nIn the example above, **Employee** type inherits from **Person**. It does so by assigning a new instance of `Person` to `Employee` prototype. After that, every instance of `Employee` inherits its properties and methods from `Person`.\n\n```javascript\n//Prototypal Inheritance \nEmployee.prototype = new Person(\"Nishant\", 24,5000);\n\nvar emp1 = new Employee(\"Google\");\n\nconsole.log(emp1 instanceof Person); // true\nconsole.log(emp1 instanceof Employee); // true\n```\n\nLet's understand Constructor inheritance\n\n```javascript\n//Defined Person class\nfunction Person(name){\n\tthis.name = name || \"Nishant\";\n}\n\nvar obj = {};\n\n// obj inherit Person class properties and method \nPerson.call(obj); // constructor inheritance\n\nconsole.log(obj); // Object {name: \"Nishant\"}\n```\nHere we saw calling **Person.call(obj)** define the name properties from `Person` to `obj`.\n\n```javascript\nconsole.log(name in obj); // true\n```\nType-based inheritance is best used with developer defined constructor function rather than natively in JavaScript. In addition to this also allows flexibility in how we create similar type of object.",
        "category": "Inheritance",
        "difficulty": "Hard"
    },
    {
        "id": 41,
        "question": "## How we can prevent modification of object in JavaScript?",
        "example": "```javascript\n// Prevent Extensions\nvar employee = { name: \"Nishant\" };\nObject.preventExtensions(employee);\nemployee.name = \"John\"; // works fine\nemployee.age = 24; // fails silently\n\n// Seal\nvar employee = { name: \"Nishant\" };\nObject.seal(employee);\ndelete employee.name; // fails silently\nemployee.age = 30; // fails silently\n\n// Freeze\nvar employee = { name: \"Nishant\" };\nObject.freeze(employee);\nemployee.name = \"xyz\"; // fails silently\nemployee.age = 30; // fails silently\ndelete employee.name; // fails silently\n```",
        "solution": "ECMAScript 5 introduce several methods to prevent modification of object which lock down object to ensure that no one, accidentally or otherwise, change functionality of Object.\n\nThere are three levels of preventing modification:\n\n**1: Prevent extensions :**\n\nNo new properties or methods can be added to the object, but one can change the existing properties and method.\n\nFor example:\n\n```javascript\nvar employee = {\n\tname: \"Nishant\"\n};\n\n// lock the object \nObject.preventExtensions(employee);\n\n// Now try to change the employee object property name\nemployee.name = \"John\"; // work fine \n\n//Now try to add some new property to the object\nemployee.age = 24; // fails silently unless it's inside the strict mode\n```\n**2: Seal :**\n\nIt is same as prevent extension, in addition to this also prevent existing properties and methods from being deleted.\n\nTo seal an object, we use **Object.seal()** method. you can check whether an object is sealed or not using **Object.isSealed();**\n\n```javascript\nvar employee = {\n\tname: \"Nishant\"\n};\n\n// Seal the object \nObject.seal(employee);\n\nconsole.log(Object.isExtensible(employee)); // false\nconsole.log(Object.isSealed(employee)); // true\n\ndelete employee.name // fails silently unless it's in strict mode\n\n// Trying to add new property will give an error\nemployee.age = 30; // fails silently unless in strict mode\n```\n\nwhen an object is sealed, its existing properties and methods can't be removed. Sealed object are also non-extensible.\n\n**3: Freeze :**\n\nSame as seal, In addition to this prevent existing properties methods from being modified (All properties and methods are read only).\n\nTo freeze an object, use Object.freeze() method. We can also determine whether an object is frozen using Object.isFrozen();\n\n```javascript\nvar employee = {\n\tname: \"Nishant\"\n};\n\n//Freeze the object\nObject.freeze(employee); \n\n// Seal the object \nObject.seal(employee);\n\nconsole.log(Object.isExtensible(employee)); // false\nconsole.log(Object.isSealed(employee));     // true\nconsole.log(Object.isFrozen(employee));     // true\n\n\nemployee.name = \"xyz\"; // fails silently unless in strict mode\nemployee.age = 30;     // fails silently unless in strict mode\ndelete employee.name   // fails silently unless it's in strict mode\n```\n\nFrozen objects are considered both non-extensible and sealed.\n\n**Recommended:**\n\nIf you are decided to prevent modification, sealed, freeze the object then use in strict mode so that you can catch the error.\n\nFor example:\n\n```javascript\n\"use strict\";\n\nvar employee = {\n\tname: \"Nishant\"\n};\n\n//Freeze the object\nObject.freeze(employee); \n\n// Seal the object \nObject.seal(employee);\n\nconsole.log(Object.isExtensible(employee)); // false\nconsole.log(Object.isSealed(employee));     // true\nconsole.log(Object.isFrozen(employee));     // true\n\n\nemployee.name = \"xyz\"; // fails silently unless in strict mode\nemployee.age = 30;     // fails silently unless in strict mode\ndelete employee.name;  // fails silently unless it's in strict mode\n```",
        "category": "Objects",
        "difficulty": "Hard"
    },
    {
        "id": 42,
        "question": "## Write a log function which will add prefix `(your message)` to every message you log using console.log?\n\nFor example, If you log `console.log(\"Some message\")` then output should be **(your message) Some message**",
        "example": "```javascript\nfunction appLog() {\n  var args = Array.prototype.slice.call(arguments);\n  args.unshift('(your message)');\n  console.log.apply(console, args);\n}\n\nappLog(\"Some error message\");\n//output: (your message) Some error message\n\nappLog(\"Another message\", \"with multiple\", \"arguments\");\n//output: (your message) Another message with multiple arguments\n```",
        "solution": "Logging error message or some informative message is always required when you dealing with client side JavaScript using console.log method. Some time you want to add some prefix to identify message generated log from your application hence you would like to prefix your app name in every console.log.\n\nA general way to do this keep adding your app name in every console.log message like\n\n```javascript\nconsole.log('your app name' + 'some error message');\n```\nBut doing in this way you have to write your app name everytime when you log message using console.\n\nThere are some best way we can achieve this\n\n```javascript\nfunction appLog() {\n  var args = Array.prototype.slice.call(arguments);\n  args.unshift('(your message)');\n  console.log.apply(console, args);\n}\n\nappLog(\"Some error message\"); \n//output of above console: '(your message) Some error message'\n```",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 43,
        "question": "## Write a function which will test string as a literal and as an object?\n\nFor example: We can create string using string literal and using String constructor function.\n\n```javascript\n// using string literal\nvar ltrlStr = \"Hi I am string literal\";\n// using String constructor function\nvar objStr = new String(\"Hi I am string object\");\n```",
        "example": "```javascript\nfunction isString(str) {\n\treturn typeof str == 'string' || str instanceof String;\n}\n\nvar ltrlStr = \"Hi I am string literal\";\nvar objStr = new String(\"Hi I am string object\");\n\nconsole.log(isString(ltrlStr)); // true\nconsole.log(isString(objStr));  // true\n```",
        "solution": "We can use typeof operator to test string literal and instanceof operator to test String object.\n\n```javascript\n function isString(str) {\n \treturn typeof str == 'string' || str instanceof String;\n }\n \n var ltrlStr = \"Hi I am string literal\";\n var objStr = new String(\"Hi I am string object\");\n console.log(isString(ltrlStr)); // true\n console.log(isString(objStr)); // true\n```",
        "category": "Strings",
        "difficulty": "Medium"
    },
    {
        "id": 44,
        "question": "## What is typical use case for anonymous function in JavaScript?",
        "example": "```javascript\n// Use case 1: Event handlers\nsetTimeout(function() {\n\talert('hello');\n}, 1000);\n\n// Use case 2: Callback functions\nvar numbers = [1, 2, 3, 4, 5];\nvar doubled = numbers.map(function(x) {\n\treturn x * 2;\n});\n\n// Use case 3: IIFE\n(function() {\n\tvar privateVar = 'I am private';\n\tconsole.log(privateVar);\n})();\n\n// Use case 4: Event listeners\ndocument.getElementById('button').addEventListener('click', function() {\n\tconsole.log('Button clicked!');\n});\n```",
        "solution": "Anonymous functions basically used in following scenario.\n\n1. No name is needed if function is only used in one place, then there is no need to add a name to function.\n\n\t```javascript\n\tsetTimeout(function(){\n\t\talert('hello');\n\t}, 1000);\n\t```\n\tHere there is no need of using named function when we are sure that function which will alert `hello` would use only once in application.\n\n2. Anonymous functions are declared inline and inline functions have advantages in the case that they can access variable in the parent scopes.\n\n\t```javascript\n\tfunction getData(options, callback) {\n\t\t// processing code\n\t\tcallback({\n\t\t\tname: 'John',\n\t\t\tage: 30\n\t\t});\n\t}\n\t\n\tgetData({}, function(data) {\n\t\tconsole.log(data.name);\n\t});\n\t```\n\tAbove example shows used of anonymous function as a callback function in event handler.\n\n3. Passing anonymous function as a parameter to calling function.\n\n\t```javascript\n\tvar numbers = [1, 2, 3];\n\tvar doubles = numbers.map(function(number) {\n\t\treturn number * 2;\n\t});\n\tconsole.log(doubles); // [2, 4, 6]\n\t```\n\nThe best way to make a decision for using anonymous function is to ask the following question:\n\n Will the function which I am going to define, be used anywhere else?\n\nIf your answer is yes then go and create named function rather anonymous function.\n\n**Advantage of using anonymous function:**\n\n1. It can reduce a bit of code, particularly in recursive function and in callback function.\n2.  Avoid needless global namespace pollutions.",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 45,
        "question": "## How to set a default parameter value?",
        "example": "```javascript\n// ES5 Method 1\nfunction sentEmail(configuration, provider) {\n  provider = provider || 'Gmail';\n  console.log(`Provider: ${provider}`);\n}\n\n// ES5 Method 2\nfunction sentEmail(configuration, provider) {\n  provider = typeof provider !== 'undefined' ? provider : 'Gmail';\n  console.log(`Provider: ${provider}`);\n}\n\n// ES6 Method\nfunction sendEmail(configuration, provider = \"Gmail\") {\n  console.log(`Provider: ${provider}`);\n}\n\nsentEmail({from: 'xyz@gmail.com'});           // Provider: Gmail\nsentEmail({from: 'xyz@gmail.com'}, 'Yahoo');  // Provider: Yahoo\n```",
        "solution": "If you are coming from python/c# you might be using default value for function parameter incase value(formal parameter) has not been passed. For instance :\n\n```python\n// Define sentEmail function \n// configuration : Configuration object\n// provider : Email Service provider, Default would be gmail\ndef sentEmail(configuration, provider = 'Gmail'):\n\t# Your code logic\n```\n**In Pre ES6/ES2015**\n\nThere are a lot of ways by which you can achieve this in pre ES2015.\n\nLet's understand the code below by which we achieved setting default parameter value.\n\n**Method 1: Setting default parameter value**\n\n```javascript\nfunction sentEmail(configuration, provider) {\n  // Set default value if user has not passed value for provider\n  provider = provider || 'Gmail';\n  // Your code logic\n;\n}\n// In this call we are not passing provider parameter value\nsentEmail({\n  from: 'xyz@gmail.com',\n  subject: 'Test Email'\n});\n// Here we are passing Yahoo Mail as a provider value\nsentEmail({\n  from: 'xyz@gmail.com',\n  subject: 'Test Email'\n}, 'Yahoo Mail');\n```\n\n**Method 2: Setting default parameter value**\n\n```javascript\nfunction sentEmail(configuration, provider) {\n  // Set default value if user has not passed value for provider\n  provider = typeof provider !== 'undefined' ? provider : 'Gmail';\n  // Your code logic\n;\n}\n// In this call we are not passing provider parameter value\nsentEmail({\n  from: 'xyz@gmail.com',\n  subject: 'Test Email'\n});\n// Here we are passing Yahoo Mail as a provider value\nsentEmail({\n  from: 'xyz@gmail.com',\n  subject: 'Test Email'\n}, 'Yahoo Mail');\n```\n\n**Method 3: Setting default parameter value in ES6**\n```javascript\nfunction sendEmail(configuration, provider = \"Gmail\") {\n  // Set default value if user has not passed value for provider\n  console.log(`Provider: ${provider}`);\n}\n\n// In this call we are not passing provider parameter value\nsentEmail({\n  from: 'xyz@gmail.com',\n  subject: 'Test Email'\n});\n// Here we are passing Yahoo Mail as a provider value\nsentEmail({\n  from: 'xyz@gmail.com',\n  subject: 'Test Email'\n}, 'Yahoo Mail');\n```",
        "category": "Functions",
        "difficulty": "Medium"
    },
    {
        "id": 46,
        "question": "## Write code for merge two JavaScript Object dynamically.\n\nLet say you have two objects\n\n```javascript\nvar person = {\n\tname : 'John',\n\tage  : 24\n}\n\nvar address = {\n\taddressLine1 : 'Some Location x',\n\taddressLine2 : 'Some Location y',\n\tcity : 'NewYork'\n} \n```\n\nWrite merge function which will take two object and add all the own property of second object into first object.",
        "example": "```javascript\n// Method 1: Using ES6, Object.assign method\nconst merge = (toObj, fromObj) => Object.assign(toObj, fromObj);\n\n// Method 2: Without using built-in function\nfunction merge(toObj, fromObj) {\n  if (typeof toObj === 'object' && typeof fromObj === 'object') {\n    for (var pro in fromObj) {\n      if (fromObj.hasOwnProperty(pro)) {\n        toObj[pro] = fromObj[pro];\n      }\n    }\n  } else {\n    throw \"Merge function can apply only on object\";\n  }\n}\n\nmerge(person, address);\nconsole.log(person); // {name: 'John', age: 24, addressLine1: 'Some Location x', addressLine2: 'Some Location y', city: 'NewYork'}\n```",
        "solution": "```javascript\nmerge(person , address); \n \n/* Now person should have 5 properties \nname , age , addressLine1 , addressLine2 , city */\n```\n**Method 1: Using ES6, Object.assign method**\n\n```javascript\nconst merge = (toObj, fromObj) => Object.assign(toObj, fromObj);\n```\n \n**Method 2: Without using built-in function**\n\n```javascript\nfunction merge(toObj, fromObj) {\n  // Make sure both of the parameter is an object\n  if (typeof toObj === 'object' && typeof fromObj === 'object') {\n    for (var pro in fromObj) {\n      // Assign only own properties not inherited properties\n      if (fromObj.hasOwnProperty(pro)) {\n        // Assign property and value\n        toObj[pro] = fromObj[pro];\n      }\n    }\n  }else{\n  \tthrow \"Merge function can apply only on object\";\n  }\n}\n```",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 47,
        "question": "## What is non-enumerable property in JavaScript and how you can create one?",
        "example": "```javascript\nvar person = {\n\tname: 'John'\n};\nperson.salary = '10000$';\nperson['country'] = 'USA';\n\n// Create non-enumerable property\nObject.defineProperty(person, 'phoneNo',{\n\tvalue : '8888888888',\n\tenumerable: false\n})\n\nconsole.log(Object.keys(person)); // ['name', 'salary', 'country']\nconsole.log(person.phoneNo); // '8888888888'\n\n// Try to change non-writable property\nperson.phoneNo = '7777777777'; // fails silently (or throws error in strict mode)\nconsole.log(person.phoneNo); // '8888888888' (unchanged)\n```",
        "solution": "Object can have properties that don't show up when you iterate through object using for...in loop or using Object.keys() to get an array of property names. This properties is know as non-enumerable properties.\n\nLet say we have following object\n\n```javascript\nvar person = {\n\tname: 'John'\n};\nperson.salary = '10000$';\nperson['country'] = 'USA';\n\nconsole.log(Object.keys(person)); // ['name', 'salary', 'country']\n```\nAs we know that person object properties `name`, `salary` ,`country` are enumerable hence it's shown up when we called Object.keys(person).\n\nTo create a non-enumerable property we have to use **Object.defineProperty()**. This is a special method for creating non-enumerable property in JavaScript.\n\n```javascript\nvar person = {\n\tname: 'John'\n};\nperson.salary = '10000$';\nperson['country'] = 'USA';\n\n// Create non-enumerable property\nObject.defineProperty(person, 'phoneNo',{\n\tvalue : '8888888888',\n\tenumerable: false\n})\n\nObject.keys(person); // ['name', 'salary', 'country']\n```\nIn the example above `phoneNo` property didn't show up because we made it non-enumerable by setting **enumerable:false**\n\n**Bonus**\n\nNow let's try to change value of `phoneNo`\n\n```javascript\nperson.phoneNo = '7777777777'; \n```\n\n**Object.defineProperty()** also lets you create read-only properties as we saw above, we are not able to modify phoneNo value of a person object. This is because descriptor has **writable** property, which is `false` by default. Changing non-writable property value will return error in strict mode. In non-strict mode it won't through any error but it won't change the value of phoneNo.",
        "category": "Objects",
        "difficulty": "Hard"
    },
    {
        "id": 48,
        "question": "## What is Function binding?",
        "example": "```javascript\nvar clickHandler = {\n\tmessage: 'click event handler',\n\thandleClick: function(event) {\n\t\tconsole.log(this.message);\n\t}\n};\n\nvar btn = document.getElementById('myBtn');\n\n// Without binding - 'this' will refer to btn element\nbtn.addEventListener('click', clickHandler.handleClick); // logs: undefined\n\n// With binding - 'this' will refer to clickHandler object\nbtn.addEventListener('click', clickHandler.handleClick.bind(clickHandler)); // logs: 'click event handler'\n```",
        "solution": "Function binding falls in advance JavaScript category and this is very popular technique to use in conjunction with event handler and callback function to preserve code execution context while passing function as a parameter.\n\nLet's consider the following example:\n\n```javascript\nvar clickHandler = {\n\tmessage: 'click event handler',\n\thandleClick: function(event) {\n\t\tconsole.log(this.message);\n\t}\n};\n\nvar btn = document.getElementById('myBtn');\n// Add click event to btn\nbtn.addEventListener('click', clickHandler.handleClick);\n```\n\nHere in this example clickHandler object is created which contain message properties and handleClick method.\n\nWe have assigned handleClick method to a DOM button, which will be executed in response of click. When the button is clicked, then handleClick method is being called and console message. Here console.log should log the `click event handler` message but it actually log `undefined`.\n\nThe problem of displaying `undefined` is because of the execution context of clickHandler.handleClick method is not being saved hence `this` pointing to button `btn` object. We can fix this issue using bind method.\n\n```javascript\nvar clickHandler = {\n\tmessage: 'click event handler',\n\thandleClick: function(event) {\n\t\tconsole.log(this.message);\n\t}\n};\n\nvar btn = document.getElementById('myBtn');\n// Add click event to btn and bind the clickHandler object\nbtn.addEventListener('click', clickHandler.handleClick.bind(clickHandler));\n```\n\n`bind` method is available to all the function similar to call and apply method which take argument value of `this`.",
        "category": "Functions",
        "difficulty": "Hard"
    },
    {
        "id": 49,
        "question": "## How to replace callback hell with Promise or Async/Await with examples?",
        "example": "```javascript\n// Callback Hell Example\nconst addTen = (num, callback) => {\n  callback(num + 10, false);\n};\n\nconst subFive = (num, callback) => {\n  callback(num - 5, false);\n};\n\nconst mulTwo = (num, callback) => {\n  callback(num * 2, false);\n};\n\n// Nested callbacks (callback hell)\naddTen(5, (addRes, addErr) => {\n  if (!addErr) {\n    subFive(addRes, (subRes, subErr) => {\n      if (!subErr) {\n        mulTwo(subRes, (mulRes, mulErr) => {\n          if (!mulErr) {\n            console.log(mulRes); // 20\n          }\n        });\n      }\n    });\n  }\n});\n\n// Promise Solution\nconst promise = new Promise((resolve) => resolve(5));\npromise\n  .then(val => val + 10)\n  .then(val => val - 5)\n  .then(val => val * 2)\n  .then(result => console.log(result)) // 20\n  .catch(err => console.log(err));\n\n// Async/Await Solution\nconst calculate = async (num) => {\n  try {\n    const addRes = await Promise.resolve(num + 10);\n    const subRes = await Promise.resolve(addRes - 5);\n    const mulRes = await Promise.resolve(subRes * 2);\n    console.log(mulRes); // 20\n  } catch (err) {\n    console.log(err);\n  }\n};\n\ncalculate(5);\n```",
        "solution": "- Part I Callbackhell.\n- Calling one callback function inside another and so on is callbackhell.\n- First we are defining three functions addTen, subFive and mulTwo. \n- These three functions while called with a number, will return a callback.\n- The callback function will return either result or error.\n\n```js\nconst addTen = (num, callback) =>\n  {return callback(num+10, false)}\n```\n\n```js\nconst subFive = (num, callback) =>\n  {return callback(num-5, false)}\n```\n\n```js\nconst mulTwo = (num, callback) =>\n  {return callback(num*2, false)}\n```\n\n- Now lets call these one by one in nested way.\n- The result of previous will serve as input for next callback.\n\n```js\nconst ans = addTen(5, (addRes, addErr) => { // addRess = 15\n        if(!addErr)\n        {\n            return subFive(addRes , (subRes, subErr) => { //subRes = 10\n                if(!subErr){\n                    return mulTwo(subRes, (mulRes, mulErr) => {\n                        if(!mulErr)\n                        {\n                            return mulRes; //20\n                        }\n                    })\n                }\n            })\n        }\n    }) \nconsole.log(ans); // 20\n```\n\n- Part II Promise.\n- Promise has two parameters resolve and reject. \n- Rewrting those three function definations as well, without a callback.\n\n```js\nconst addTen = (num) => {return num+10}\n```\n\n```js\nconst subFive = (num) => {return num-5}\n```\n\n```js\nconst mulTwo = (num) => {return num*2}\n```\n\n- Creating a promise.\n\n```js\nconst promise = new Promise((resolve, reject) => {\n    if(true)\n      resolve(5)\n    else\n      reject(\"Something went wrong \")\n})\n```\n\n- Calling those three functions one by one.\n- \"then\" will keep on returning the result and if any error \"catch\" will catch it.\n\n```js\npromise.then(addTen).then(subFive).then(mulTwo).then((ans)=>{\nconsole.log(ans)\n}).catch((err)=>{console.log(err)});\n```\n\n- Part III Async / Await.\n- It actually uses promise internally.\n\n```js\nconst addTen = ( num ) => {\n    return new Promise( ( resolve, reject ) => {\n        resolve( num+10)\n    } )\n}\n```\n\n```js\nconst subFive = ( num ) => {\n    return new Promise( ( resolve, reject ) => {\n        resolve( num-5)\n    } )\n}\n```\n\n```js\nconst mulTwo = ( num ) => {\n    return new Promise( ( resolve, reject ) => {\n        resolve( num*2)\n    } )\n}\n```\n\n- Put Async keyword before function name and Await before the statments inside the function\n- Await will make the later code wait until the result of that statement is returned.\n- Always put this inside a try/catch block.\n\n```js\nconst ans = async (num) => {\n    try {\n        var addRes = await addTen(num);\n        var subRes = await subFive(addRes);\n        var mulRes = await mulTwo(subRes);\n        console.log(mulRes)\n    } catch (err) {\n        console.log(err)\n    }\n}\nans(5)\n```",
        "category": "Asynchronous",
        "difficulty": "Hard"
    },
    {
        "id": 50,
        "question": "## What would be the output of following code?\n\n```javascript\nvar strA = \"hi there\";\nvar strB = strA;\nstrB=\"bye there!\";\nconsole.log (strA)\n```",
        "example": "```javascript\nvar strA = \"hi there\";\nvar strB = strA;       // strB gets a copy of strA's value\nstrB = \"bye there!\";   // strB is reassigned, strA remains unchanged\nconsole.log(strA);     // \"hi there\"\n\n// Strings are primitive values, passed by value\nvar num1 = 42;\nvar num2 = num1;       // num2 gets a copy of num1's value\nnum2 = 100;            // num2 is reassigned, num1 remains unchanged\nconsole.log(num1);     // 42\n```",
        "solution": "The output will be `'hi there'` because we're dealing with strings here. Strings are passed by value, that is, copied.\n\nFor a JS developer, it's crucially important to understand which values are passed by reference, and which ones are passed by value. Remember that objects, including arrays are passed by reference while strings, booleans and numbers are passed by value.",
        "category": "Data Types",
        "difficulty": "Easy"
    },
    {
        "id": 51,
        "question": "## What would be the output of following code?\n\n```javascript\nvar objA = {prop1: 42};\nvar objB = objA; \nobjB.prop1 = 90;\nconsole.log(objA) \n```",
        "example": "```javascript\n// Objects are passed by reference\nvar original = {name: 'John', age: 30};\nvar reference = original;\n\n// Modifying through reference affects original\nreference.name = 'Jane';\nreference.age = 25;\n\nconsole.log(original); // {name: 'Jane', age: 25}\nconsole.log(reference); // {name: 'Jane', age: 25}\nconsole.log(original === reference); // true (same object)\n\n// Adding new properties\nreference.city = 'New York';\nconsole.log(original.city); // 'New York'\n```",
        "solution": "The output will be `{prop1: 90}` because we're dealing with objects here. Objects are passed by reference, that is, `objA` and `objB` point to the same object in memory.",
        "category": "Objects",
        "difficulty": "Easy"
    },
    {
        "id": 52,
        "question": "## What would be the output of following code?\n\n```javascript\nvar objA = {prop1: 42};\nvar objB = objA;\nobjB = {};\nconsole.log(objA)\n```",
        "example": "```javascript\n// Reassignment vs property modification\nvar obj1 = {value: 100};\nvar obj2 = obj1;  // Both point to same object\n\nobj2.value = 200; // Modifies the shared object\nconsole.log(obj1.value); // 200\n\nobj2 = {value: 300}; // Reassigns obj2 to new object\nconsole.log(obj1.value); // 200 (obj1 unchanged)\nconsole.log(obj2.value); // 300 (obj2 points to new object)\n\n// obj1 and obj2 now point to different objects\nconsole.log(obj1 === obj2); // false\n```",
        "solution": "The output will be `{prop1: 42}`.\n\nWhen we assign `objA` to `objB`, the `objB` variable will point to the same object as the `objA` variable.\n\nHowever, when we reassign `objB` to an empty object, we simply change where `objB` variable references to. This doesn't affect where `objA` variable references to.",
        "category": "Objects",
        "difficulty": "Medium"
    },
    {
        "id": 53,
        "question": "## What would be the output of following code?\n\n```javascript\nvar arrA = [0,1,2,3,4,5];\nvar arrB = arrA;\narrB[0]=42;\nconsole.log(arrA)\n```",
        "example": "```javascript\n// Arrays are objects and passed by reference\nvar original = [1, 2, 3, 4, 5];\nvar reference = original;\n\n// Modifying through reference affects original\nreference[0] = 999;\nreference.push(6);\n\nconsole.log(original);  // [999, 2, 3, 4, 5, 6]\nconsole.log(reference); // [999, 2, 3, 4, 5, 6]\nconsole.log(original === reference); // true (same array)\n\n// Using array methods\nreference.splice(1, 1); // Remove element at index 1\nconsole.log(original); // [999, 3, 4, 5, 6]\n```",
        "solution": "The output will be `[42,1,2,3,4,5]`.\n\nArrays are object in JavaScript and they are passed and assigned by reference. This is why both `arrA` and `arrB` point to the same array `[0,1,2,3,4,5]`. That's why changing the first element of the `arrB` will also modify `arrA`: it's the same array in the memory.",
        "category": "Arrays",
        "difficulty": "Easy"
    },
    {
        "id": 54,
        "question": "## What would be the output of following code?\n\n```javascript\nvar arrA = [0,1,2,3,4,5];\nvar arrB = arrA.slice();\narrB[0]=42;\nconsole.log(arrA)\n```",
        "example": "```javascript\n// slice() creates a shallow copy\nvar original = [1, 2, 3, 4, 5];\nvar copy = original.slice();\n\n// Modifying copy doesn't affect original\ncopy[0] = 999;\ncopy.push(6);\n\nconsole.log(original); // [1, 2, 3, 4, 5] (unchanged)\nconsole.log(copy);     // [999, 2, 3, 4, 5, 6]\nconsole.log(original === copy); // false (different arrays)\n\n// Different slice() examples\nvar arr = [1, 2, 3, 4, 5];\nconsole.log(arr.slice());     // [1, 2, 3, 4, 5] (full copy)\nconsole.log(arr.slice(1));    // [2, 3, 4, 5] (from index 1)\nconsole.log(arr.slice(1, 3)); // [2, 3] (from index 1 to 3)\n```",
        "solution": "The output will be `[0,1,2,3,4,5]`.\n\nThe `slice` function copies all the elements of the array returning the new array. That's why `arrA` and `arrB` reference two completely different arrays.",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 55,
        "question": "## What would be the output of following code?\n\n```javascript\nvar arrA = [{prop1: \"value of array A!!\"}, {someProp: \"also value of array A!\"}, 3,4,5];\nvar arrB = arrA;\narrB[0].prop1=42;\nconsole.log(arrA);\n```",
        "example": "```javascript\n// Shared object references in arrays\nvar arr1 = [{name: 'John'}, {name: 'Jane'}];\nvar arr2 = arr1;\n\n// Modifying object properties affects both arrays\narr2[0].name = 'Bob';\narr2[1].age = 30;\n\nconsole.log(arr1); // [{name: 'Bob'}, {name: 'Jane', age: 30}]\nconsole.log(arr2); // [{name: 'Bob'}, {name: 'Jane', age: 30}]\n\n// Both arrays point to the same objects\nconsole.log(arr1[0] === arr2[0]); // true\n\n// Reassigning array element creates new reference\narr2[0] = {name: 'Alice'};\nconsole.log(arr1[0].name); // 'Bob' (original object unchanged)\nconsole.log(arr2[0].name); // 'Alice' (new object)\n```",
        "solution": "The output will be `[{prop1: 42}, {someProp: \"also value of array A!\"}, 3, 4, 5]`.\n\nArrays are object in JS, so both variables arrA and arrB point to the same array. Changing `arrB[0]` is the same as changing `arrA[0]`",
        "category": "Arrays",
        "difficulty": "Medium"
    },
    {
        "id": 56,
        "question": "## What would be the output of following code?\n\n```javascript\nvar arrA = [{prop1: \"value of array A!!\"}, {someProp: \"also value of array A!\"},3,4,5];\nvar arrB = arrA.slice();\narrB[0].prop1=42;\narrB[3] = 20;\nconsole.log(arrA);\n```",
        "example": "```javascript\n// Shallow copy with slice() - objects still shared\nvar original = [{name: 'John'}, {name: 'Jane'}, 3, 4, 5];\nvar copy = original.slice();\n\n// Arrays are different, but objects inside are shared\nconsole.log(original === copy); // false (different arrays)\nconsole.log(original[0] === copy[0]); // true (same object reference)\n\n// Modifying object properties affects both arrays\ncopy[0].name = 'Bob';\nconsole.log(original[0].name); // 'Bob' (shared object modified)\n\n// Modifying primitive values only affects the copy\ncopy[2] = 999;\nconsole.log(original[2]); // 3 (primitive unchanged)\nconsole.log(copy[2]);     // 999\n\n// Adding elements only affects the copy\ncopy.push(6);\nconsole.log(original.length); // 5\nconsole.log(copy.length);     // 6\n```",
        "solution": "The output will be `[{prop1: 42}, {someProp: \"also value of array A!\"}, 3, 4, 5]`.\n\nThe `slice` function copies all the elements of the array returning the new array. However, it doesn't do deep copying. Instead it does shallow copying. You can imagine slice implemented like this:\n\n```javascript\nfunction slice(arr) {\n    var result = [];\n    for (i = 0; i< arr.length; i++) {\n        result.push(arr[i]);\n    }\n    return result; \n}\n```\n\nLook at the line with `result.push(arr[i])`. If `arr[i]` happens to be a number or string, it will be passed by value, in other words, copied. If `arr[i]` is an object, it will be passed by reference.\n\nIn case of our array `arr[0]` is an object `{prop1: \"value of array A!!\"}`. Only the reference to this object will be copied. This effectively means that arrays arrA and arrB share first two elements.\n\nThis is why changing the property of `arrB[0]` in `arrB` will also change the `arrA[0]`.",
        "category": "Arrays",
        "difficulty": "Hard"
    },
    {
        "id": 57,
        "question": "## console.log(employeeId);\n\n1. Some Value\n2. Undefined\n3. Type Error\n4. ReferenceError: employeeId is not defined",
        "example": "```javascript\n// Trying to access undeclared variable\nconsole.log(undeclaredVar); // ReferenceError: undeclaredVar is not defined\n\n// vs declared but undefined\nvar declaredVar;\nconsole.log(declaredVar); // undefined\n\n// vs checking with typeof (safe)\nconsole.log(typeof undeclaredVar); // \"undefined\" (no error)\nconsole.log(typeof declaredVar);   // \"undefined\"\n```",
        "solution": "**Answer: 4) ReferenceError: employeeId is not defined**\n\n**Explanation:** When we try to access a variable that has not been declared anywhere in the code, JavaScript throws a `ReferenceError`. Since `employeeId` is neither declared nor defined, attempting to log it results in a reference error.",
        "category": "Hoisting",
        "difficulty": "Easy"
    },
    {
        "id": 58,
        "question": "## What would be the output of following code?\n\n```javascript\nconsole.log(employeeId);\nvar employeeId = '19000';\n```\n\n1. Some Value\n2. undefined\n3. Type Error\n4. ReferenceError: employeeId is not defined",
        "example": "```javascript\n// Due to hoisting, this code:\nconsole.log(employeeId);\nvar employeeId = '19000';\n\n// Is effectively interpreted as:\nvar employeeId; // hoisted declaration\nconsole.log(employeeId); // undefined (declared but not assigned)\nemployeeId = '19000'; // assignment happens here\n\n// More examples of hoisting\nconsole.log(a); // undefined\nvar a = 5;\nconsole.log(a); // 5\n```",
        "solution": "**Answer: 2) undefined**\n\n**Explanation:** Due to hoisting, the variable declaration `var employeeId` is moved to the top of the scope, but the assignment happens at the original line. So the code effectively becomes:\n\n```javascript\nvar employeeId; // hoisted declaration\nconsole.log(employeeId); // undefined (declared but not yet assigned)\nemployeeId = '19000'; // assignment happens here\n```",
        "category": "Hoisting",
        "difficulty": "Medium"
    },
    {
        "id": 59,
        "question": "## What would be the output of following code?\n\n```javascript\nvar employeeId = '1234abe';\n(function(){\n\tconsole.log(employeeId);\n\tvar employeeId = '122345';\n})();\n```\n\n1. '122345'\n2. undefined\n3. Type Error\n4. ReferenceError: employeeId is not defined",
        "example": "```javascript\n// IIFE with variable shadowing\nvar globalVar = 'global';\n(function(){\n    console.log(globalVar); // undefined (not 'global')\n    var globalVar = 'local'; // local declaration shadows global\n    console.log(globalVar); // 'local'\n})();\n\n// This is effectively:\n(function(){\n    var globalVar; // hoisted local declaration\n    console.log(globalVar); // undefined\n    globalVar = 'local';\n    console.log(globalVar); // 'local'\n})();\n```",
        "solution": "**Answer: 2) undefined**\n\n**Explanation:** Inside the IIFE (Immediately Invoked Function Expression), the `var employeeId` declaration is hoisted to the top of the function scope. This creates a local variable that shadows the global `employeeId`. The code effectively becomes:\n\n```javascript\nvar employeeId = '1234abe'; // global\n(function(){\n\tvar employeeId; // hoisted local declaration\n\tconsole.log(employeeId); // undefined (local variable, not yet assigned)\n\temployeeId = '122345'; // assignment to local variable\n})();\n```",
        "category": "Hoisting",
        "difficulty": "Hard"
    },
    {
        "id": 60,
        "question": "## What would be the output of following code?\n\n```javascript\nvar employeeId = '1234abe';\n(function() {\n\tconsole.log(employeeId);\n\tvar employeeId = '122345';\n\tconsole.log(employeeId);\n}());\n```\n\n1. '1234abe' '122345'\n2. undefined '122345'\n3. '1234abe' undefined\n4. undefined undefined",
        "example": "```javascript\n// Complete example with hoisting and shadowing\nvar global = 'outer';\n\n(function() {\n    console.log(global); // undefined (not 'outer')\n    var global = 'inner'; // local declaration shadows global\n    console.log(global); // 'inner'\n})();\n\n// This is effectively:\n(function() {\n    var global; // hoisted local declaration\n    console.log(global); // undefined\n    global = 'inner';\n    console.log(global); // 'inner'\n})();\n```",
        "solution": "**Answer: 2) undefined '122345'**\n\n**Explanation:** The local `var employeeId` declaration is hoisted to the top of the function scope, shadowing the global variable. The first `console.log` executes before the assignment, so it prints `undefined`. The second `console.log` executes after the assignment, so it prints `'122345'`.",
        "category": "Hoisting",
        "difficulty": "Hard"
    }
]